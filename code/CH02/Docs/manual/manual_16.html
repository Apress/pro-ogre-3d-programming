<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html40/loose.dtd">
<HTML>
<!-- Created on July 23 2006 by texi2html 1.66 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<HEAD>
<TITLE>OGRE Manual v1.2.2 ('Dagon'): Passes</TITLE>

<META NAME="description" CONTENT="OGRE Manual v1.2.2 ('Dagon'): Passes">
<META NAME="keywords" CONTENT="OGRE Manual v1.2.2 ('Dagon'): Passes">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.66">
<LINK TYPE="text/css" rel="stylesheet" href="../style.css"> 
</HEAD>

<BODY LANG="en" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC35"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_15.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC23"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_17.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<HR SIZE=1>
<H3> 3.1.2 Passes </H3>
<!--docid::SEC35::-->
A pass is a single render of the geometry in question; a single call to the rendering API with a certain set of rendering properties. A technique can have between one and 16 passes, although clearly the more passes you use, the more expensive the technique will be to render.<BR><BR>
<P>

To help clearly identify what each pass is used for, the pass can be named but its optional.  Passes not named within the script will take on a name that is the pass index number.  For example: the first pass in a technique is index 0 so its name would be &quot;0&quot; if it was not given a name in the script.  The pass name must be unqiue within the technique or else the final pass is the resulting merge of all passes with the same name in the technique.  A warning message is posted in the Ogre.log if this occurs.  Named passes can help when copying a material and modifying an existing pass: (See section <A HREF="manual_20.html#SEC105">3.1.6 Copying Materials</A>)<BR><BR>
</P>
<P>

Passes have a set of global attributes (described below), zero or more nested texture_unit entries (See section <A HREF="manual_17.html#SEC61">3.1.3 Texture Units</A>), and optionally a reference to a vertex and / or a fragment program (See section <A HREF="manual_19.html#SEC98">3.1.5 Using Vertex and Fragment Programs in a Pass</A>).
</P>
<P>

<BR><BR>
Here are the attributes you can use in a 'pass' section of a .material script:
</P>
<P>

<UL>
<LI>
<A HREF="manual_16.html#SEC37">ambient</A>
<LI>
<A HREF="manual_16.html#SEC38">diffuse</A>
<LI>
<A HREF="manual_16.html#SEC39">specular</A>
<LI>
<A HREF="manual_16.html#SEC40">emissive</A>
<LI>
<A HREF="manual_16.html#SEC41">scene_blend</A>
<LI>
<A HREF="manual_16.html#SEC42">depth_check</A>
<LI>
<A HREF="manual_16.html#SEC43">depth_write</A>
<LI>
<A HREF="manual_16.html#SEC44">depth_func</A>
<LI>
<A HREF="manual_16.html#SEC45">depth_bias</A>
<LI>
<A HREF="manual_16.html#SEC46">alpha_rejection</A>
<LI>
<A HREF="manual_16.html#SEC47">cull_hardware</A>
<LI>
<A HREF="manual_16.html#SEC48">cull_software</A>
<LI>
<A HREF="manual_16.html#SEC49">lighting</A>
<LI>
<A HREF="manual_16.html#SEC50">shading</A>
<LI>
<A HREF="manual_16.html#SEC51">polygon_mode</A>
<LI>
<A HREF="manual_16.html#SEC52">fog_override</A>
<LI>
<A HREF="manual_16.html#SEC53">colour_write</A>
<LI>
<A HREF="manual_16.html#SEC54">max_lights</A>
<LI>
<A HREF="manual_16.html#SEC55">iteration</A>
<LI>
<A HREF="manual_16.html#SEC56">point_size</A>
<LI>
<A HREF="manual_16.html#SEC57">point_sprites</A>
<LI>
<A HREF="manual_16.html#SEC58">point_size_attenuation</A>
<LI>
<A HREF="manual_16.html#SEC59">point_size_min</A>
<LI>
<A HREF="manual_16.html#SEC60">point_size_max</A>
</UL>
<P>

<A NAME="SEC36"></A>
<H2> Attribute Descriptions </H2>
<!--docid::SEC36::-->
<A NAME="ambient"></A>
<A NAME="SEC37"></A>
<H3> ambient </H3>
<!--docid::SEC37::-->
<P>

Sets the ambient colour reflectance properties of this pass. <STRONG>This attribute has no effect if a asm, CG, or HLSL shader program is used.  With GLSL, the shader can read the OpenGL material state.</STRONG> <BR><BR>
</P>
<P>

Format: ambient (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<BR>
NB valid colour values are between 0.0 and 1.0.<BR><BR>
</P>
<P>

Example: ambient 0.0 0.8 0.0<BR><BR>
</P>
<P>

The base colour of a pass is determined by how much red, green and blue light is reflects at each vertex. This property determines how much ambient light (directionless global light) is reflected. 
It is also possible to make the ambient reflectance track the vertex colour as defined in the mesh by using the keyword vertexcolour instead of the colour values.
The default is full white, meaning objects are completely globally illuminated. Reduce this if you want to see diffuse or specular light effects, or change the blend of colours to make the object have a base colour other than white. This setting has no effect if dynamic lighting is disabled using the 'lighting off' attribute, or if any texture layer has a 'colour_op replace' attribute.<BR><BR>
</P>
<P>

Default: ambient 1.0 1.0 1.0 1.0<BR><BR>
</P>
<P>

<A NAME="diffuse"></A>
<A NAME="SEC38"></A>
<H3> diffuse </H3>
<!--docid::SEC38::-->
<P>

Sets the diffuse colour reflectance properties of this pass. <STRONG>This attribute has no effect if a asm, CG, or HLSL shader program is used.  With GLSL, the shader can read the OpenGL material state.</STRONG><BR><BR>
</P>
<P>

Format: diffuse (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<BR>
NB valid colour values are between 0.0 and 1.0.<BR><BR>
</P>
<P>

Example: diffuse 1.0 0.5 0.5<BR><BR>
</P>
<P>

The base colour of a pass is determined by how much red, green and blue light is reflects at each vertex. This property determines how much diffuse light (light from instances of the Light class in the scene) is reflected. 
It is also possible to make the diffuse reflectance track the vertex colour as defined in the mesh by using the keyword vertexcolour instead of the colour values.
The default is full white, meaning objects reflect the maximum white light they can from Light objects. This setting has no effect if dynamic lighting is disabled using the 'lighting off' attribute, or if any texture layer has a 'colour_op replace' attribute.<BR><BR>
</P>
<P>

Default: diffuse 1.0 1.0 1.0 1.0<BR><BR>
</P>
<P>

<A NAME="specular"></A>
<A NAME="SEC39"></A>
<H3> specular </H3>
<!--docid::SEC39::-->
<P>

Sets the specular colour reflectance properties of this pass. <STRONG>This attribute has no effect if a asm, CG, or HLSL shader program is used.  With GLSL, the shader can read the OpenGL material state.</STRONG><BR><BR>
</P>
<P>

Format: specular (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour) &lt;shininess&gt;<BR>
NB valid colour values are between 0.0 and 1.0. Shininess can be any value greater than 0.<BR><BR>
</P>
<P>

Example: specular 1.0 1.0 1.0 12.5<BR><BR>
</P>
<P>

The base colour of a pass is determined by how much red, green and blue light is reflects at each vertex. This property determines how much specular light (highlights from instances of the Light class in the scene) is reflected. 
It is also possible to make the diffuse reflectance track the vertex colour as defined in the mesh by using the keyword vertexcolour instead of the colour values.
The default is to reflect no specular light. The colour of the specular highlights is determined by the colour parameters, and the size of the highlights by the separate shininess parameter.. The higher the value of the shininess parameter, the sharper the highlight ie the radius is smaller.  Beware of using shininess values in the range of 0 to 1 since this causes the the specular colour to be applied to the whole surface that has the material applied to it.  When the viewing angle to the surface changes, ugly flickering will also occur when shininess is in the range of 0 to 1.  Shininess values between 1 and 128 work best in both DirectX and OpenGL renderers.  This setting has no effect if dynamic lighting is disabled using the 'lighting off' attribute, or if any texture layer has a 'colour_op replace' attribute.<BR><BR>
</P>
<P>

Default: specular 0.0 0.0 0.0 0.0 0.0<BR><BR>
</P>
<P>

<A NAME="emissive"></A>
<A NAME="SEC40"></A>
<H3> emissive </H3>
<!--docid::SEC40::-->
<P>

Sets the amount of self-illumination an object has. <STRONG>This attribute has no effect if a asm, CG, or HLSL shader program is used.  With GLSL, the shader can read the OpenGL material state.</STRONG><BR><BR>
</P>
<P>

Format: emissive (&lt;red&gt; &lt;green&gt; &lt;blue&gt; [&lt;alpha&gt;]| vertexcolour)<BR>
NB valid colour values are between 0.0 and 1.0.<BR><BR>
</P>
<P>

Example: emissive 1.0 0.0 0.0<BR><BR>
</P>
<P>

If an object is self-illuminating, it does not need external sources to light it, ambient or otherwise. It's like the object has it's own personal ambient light. Unlike the name suggests, this object doesn't act as a light source for other objects in the scene (if you want it to, you have to create a light which is centered on the object). 
It is also possible to make the emissive colour track the vertex colour as defined in the mesh by using the keyword vertexcolour instead of the colour values.
This setting has no effect if dynamic lighting is disabled using the 'lighting off' attribute, or if any texture layer has a 'colour_op replace' attribute.<BR><BR>
</P>
<P>

Default: emissive 0.0 0.0 0.0 0.0<BR><BR>
</P>
<P>

<A NAME="scene_blend"></A>
<A NAME="SEC41"></A>
<H3> scene_blend </H3>
<!--docid::SEC41::-->
<P>

Sets the kind of blending this pass has with the existing contents of the scene. Wheras the texture blending operations seen in the texture_unit entries are concerned with blending between texture layers, this blending is about combining the output of this pass as a whole with the existing contents of the rendering target. This blending therefore allows object transparency and other special effects. There are 2 formats, one using predefined blend types, the other allowing a roll-your-own approach using source and destination factors.<BR><BR>
</P>
<P>

Format1: scene_blend &lt;add|modulate|alpha_blend|colour_blend&gt;<BR><BR>
</P>
<P>

Example: scene_blend add<BR><BR>
</P>
<P>

This is the simpler form, where the most commonly used blending modes are enumerated using a single parameter. Valid &lt;blend_type&gt; parameters are:
</P>
<DL COMPACT>
<DT>add
<DD>The colour of the rendering output is added to the scene. Good for exposions, flares, lights, ghosts etc. Equivalent to 'scene_blend one one'.
<DT>modulate
<DD>The colour of the rendering output is multiplied with the scene contents. Generally colours and darkens the scene, good for smoked glass, semi-transparent objects etc. Equivalent to 'scene_blend dest_colour zero'.
<DT>colour_blend
<DD>Colour the scene based on the brightness of the input colours, but don't darken. Equivalent to 'scene_blend src_colour one_minus_src_colour'
<DT>alpha_blend
<DD>The alpha value of the rendering output is used as a mask. Equivalent to 'scene_blend src_alpha one_minus_src_alpha'
</DL>
<BR>
Format2: scene_blend &lt;src_factor&gt; &lt;dest_factor&gt;<BR><BR>
<P>

Example: scene_blend one one_minus_dest_alpha<BR><BR>
</P>
<P>

This version of the method allows complete control over the blending operation, by specifying the source and destination blending factors. The resulting colour which is written to the rendering target is (texture * sourceFactor) + (scene_pixel * destFactor). Valid values for both parameters are:
</P>
<DL COMPACT>
<DT>one
<DD>Constant value of 1.0
<DT>zero
<DD>Constant value of 0.0
<DT>dest_colour
<DD>The existing pixel colour
<DT>src_colour
<DD>The texture pixel (texel) colour
<DT>one_minus_dest_colour
<DD>1 - (dest_colour)
<DT>one_minus_src_colour
<DD>1 - (src_colour)
<DT>dest_alpha
<DD>The existing pixel alpha value
<DT>src_alpha
<DD>The texel alpha value
<DT>one_minus_dest_alpha
<DD>1 - (dest_alpha)
<DT>one_minus_src_alpha
<DD>1 - (src_alpha)
</DL>
<BR>
Default: scene_blend one zero (opaque)
<BR>
<A NAME="depth_check"></A>
<A NAME="SEC42"></A>
<H3> depth_check </H3>
<!--docid::SEC42::-->
<P>

Sets whether or not this pass renders with depth-buffer checking on or not.<BR><BR>
</P>
<P>

Format: depth_check &lt;on|off&gt;<BR><BR>
</P>
<P>

If depth-buffer checking is on, whenever a pixel is about to be written to the frame buffer the depth buffer is checked to see if the pixel is in front of all other pixels written at that point. If not, the pixel is not written. If depth checking is off, pixels are written no matter what has been rendered before. Also see depth_func for more advanced depth check configuration.<BR><BR>
</P>
<P>

Default: depth_check on<BR><BR>
</P>
<P>

<A NAME="depth_write"></A>
<A NAME="SEC43"></A>
<H3> depth_write </H3>
<!--docid::SEC43::-->
<P>

Sets whether or not this pass renders with depth-buffer writing on or not.<BR>
</P>
<P>

Format: depth_write &lt;on|off&gt;<BR><BR>
</P>
<P>

If depth-buffer writing is on, whenever a pixel is written to the frame buffer the depth buffer is updated with the depth value of that new pixel, thus affecting future rendering operations if future pixels are behind this one. If depth writing is off, pixels are written without updating the depth buffer. Depth writing should normally be on but can be turned off when rendering static backgrounds or when rendering a collection of transparent objects at the end of a scene so that they overlap each other correctly.<BR><BR>
</P>
<P>

Default: depth_write on<BR>
</P>
<P>

<A NAME="depth_func"></A>
<A NAME="SEC44"></A>
<H3> depth_func </H3>
<!--docid::SEC44::-->
<P>

Sets the function used to compare depth values when depth checking is on.<BR><BR>
</P>
<P>

Format: depth_func &lt;func&gt;<BR><BR>
</P>
<P>

If depth checking is enabled (see depth_check) a comparison occurs between the depth value of the pixel to be written and the current contents of the buffer. This comparison is normally less_equal, i.e. the pixel is written if it is closer (or at the same distance) than the current contents. The possible functions are:
</P>
<DL COMPACT>
<DT>always_fail
<DD>Never writes a pixel to the render target
<DT>always_pass
<DD>Always writes a pixel to the render target
<DT>less
<DD>Write if (new_Z &lt; existing_Z)
<DT>less_equal
<DD>Write if (new_Z &lt;= existing_Z)
<DT>equal
<DD>Write if (new_Z == existing_Z)
<DT>not_equal
<DD>Write if (new_Z != existing_Z)
<DT>greater_equal
<DD>Write if (new_Z &gt;= existing_Z)
<DT>greater
<DD>Write if (new_Z &gt;existing_Z)
</DL>
<BR>
Default: depth_func less_equal
<P>

<A NAME="depth_bias"></A>
<A NAME="SEC45"></A>
<H3> depth_bias </H3>
<!--docid::SEC45::-->
<P>

Sets the bias applied to the depth value of this pass. Can be used to make coplanar polygons appear on top of others e.g. for decals. <BR><BR>
</P>
<P>

Format: depth_bias &lt;value&gt;<BR><BR>
</P>
<P>

Where &lt;value&gt; is between 0 and 16, the default being 0. The higher the value, the greater the offset (for if you want to do multiple overlapping decals).<BR><BR>
</P>
<P>

<A NAME="alpha_rejection"></A>
<A NAME="SEC46"></A>
<H3> alpha_rejection </H3>
<!--docid::SEC46::-->
<P>

Sets the way the pass will have use alpha to totally reject pixels from the pipeline.<BR><BR>
</P>
<P>

Format: alpha_rejection &lt;function&gt; &lt;value&gt;<BR><BR>
</P>
<P>

Example: alpha_rejection greater_equal 128<BR><BR>
</P>
<P>

The function parameter can be any of the options listed in the material depth_function attribute. The value parameter can theoretically be any value between 0 and 255, but is best limited to 0 or 128 for hardware compatibility.<BR><BR>
</P>
<P>

Default: alpha_rejection always_pass<BR><BR>
</P>
<P>

<A NAME="cull_hardware"></A>
<A NAME="SEC47"></A>
<H3> cull_hardware </H3>
<!--docid::SEC47::-->
<P>

Sets the hardware culling mode for this pass.<BR><BR>
</P>
<P>

Format: cull_hardware &lt;clockwise|anticlockwise|none&gt;<BR><BR>
</P>
<P>

A typical way for the hardware rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;). If the option 'cull_hardware clockwise' is set, all triangles whose vertices are viewed in clockwise order from the camera will be culled by the hardware. 'anticlockwise' is the reverse (obviously), and 'none' turns off hardware culling so all triagles are rendered (useful for creating 2-sided passes).<BR><BR>
</P>
<P>

Default: cull_hardware clockwise<BR>
NB this is the same as OpenGL's default but the opposite of Direct3D's default (because Ogre uses a right-handed coordinate system like OpenGL).
</P>
<P>

<A NAME="cull_software"></A>
<A NAME="SEC48"></A>
<H3> cull_software </H3>
<!--docid::SEC48::-->
<P>

Sets the software culling mode for this pass.<BR><BR>
</P>
<P>

Format: cull_software &lt;back|front|none&gt;<BR><BR>
</P>
<P>

In some situations the engine will also cull geometry in software before sending it to the hardware renderer. This setting only takes effect on SceneManager's that use it (since it is best used on large groups of planar world geometry rather than on movable geometry since this would be expensive), but if used can cull geometry before it is sent to the hardware. In this case the culling is based on whether the 'back' or 'front' of the traingle is facing the camera - this definition is based on the face normal (a vector which sticks out of the front side of the polygon perpendicular to the face). Since Ogre expects face normals to be on anticlockwise side of the face, 'cull_software back' is the software equivalent of 'cull_hardware clockwise' setting, which is why they are both the default. The naming is different to reflect the way the culling is done though, since most of the time face normals are precalculated and they don't have to be the way Ogre expects - you could set 'cull_hardware none' and completely cull in software based on your own face normals, if you have the right SceneManager which uses them.<BR><BR>
</P>
<P>

Default: cull_software back<BR><BR>
</P>
<P>

<A NAME="lighting"></A>
<A NAME="SEC49"></A>
<H3> lighting </H3>
<!--docid::SEC49::-->
<P>

Sets whether or not dynamic lighting is turned on for this pass or not. If lighting is turned off, all objects rendered using the pass will be fully lit. <STRONG>This attribute has no effect if a vertex program is used.</STRONG><BR><BR>
</P>
<P>

Format: lighting &lt;on|off&gt;<BR><BR>
</P>
<P>

Turning dynamic lighting off makes any ambient, diffuse, specular, emissive and shading properties for this pass redundant. When lighting is turned on, objects are lit according to their vertex normals for diffuse and specular light, and globally for ambient and emissive.<BR><BR>
</P>
<P>

Default: lighting on<BR><BR>
</P>
<P>

<A NAME="shading"></A>
<A NAME="SEC50"></A>
<H3> shading </H3>
<!--docid::SEC50::-->
<P>

Sets the kind of shading which should be used for representing dynamic lighting for this pass.<BR><BR>
</P>
<P>

Format: shading &lt;flat|gouraud|phong&gt;<BR><BR>
</P>
<P>

When dynamic lighting is turned on, the effect is to generate colour values at each vertex. Whether these values are interpolated across the face (and how) depends on this setting.<BR><BR>
</P>
<DL COMPACT>
<DT>flat
<DD>	No interpolation takes place. Each face is shaded with a single colour determined from the first vertex in the face.
<DT>gouraud
<DD>	Colour at each vertex is linearly interpolated across the face.
<DT>phong
<DD>	Vertex normals are interpolated across the face, and these are used to determine colour at each pixel. Gives a more natural lighting effect but is more expensive and works better at high levels of tesselation. Not supported on all hardware.
</DL>
Default: shading gouraud<BR><BR>
<P>

<A NAME="polygon_mode"></A>
<A NAME="SEC51"></A>
<H3> polygon_mode </H3>
<!--docid::SEC51::-->
<P>

Sets how polygons should be rasterised, ie whether they should be filled in, or just drawn as lines or points.<BR><BR>
</P>
<P>

Format: polygon_mode &lt;solid|wireframe|points&gt;<BR><BR>
</P>
<P>

</P>
<DL COMPACT>
<DT>solid
<DD>The normal situation - polygons are filled in.
<DT>wireframe
<DD>Polygons are drawn in outline only.
<DT>points
<DD>Only the points of each polygon are rendered.
</DL>
Default: polygon_mode solid<BR><BR>
<P>

<A NAME="fog_override"></A>
<A NAME="SEC52"></A>
<H3> fog_override </H3>
<!--docid::SEC52::-->
<P>

Tells the pass whether it should override the scene fog settings, and enforce it's own. Very useful for things that you don't want to be affected by fog when the rest of the scene is fogged, or vice versa. Note that this only affects fixed-function fog - the original scene fog parameters are still sent to shaders which use the fog_params parameter binding (this allows you to turn off fixed function fog and calculate it in the shader instead; if you want to disable shader fog you can do that through shader parameters anyway). <BR><BR>
</P>
<P>

Format: fog_override &lt;override?&gt; [&lt;type&gt; &lt;colour&gt; &lt;density&gt; &lt;start&gt; &lt;end&gt;]<BR><BR>
</P>
<P>

Default: fog_override false<BR><BR>
</P>
<P>

If you specify 'true' for the first parameter and you supply the rest of the parameters, you are telling the pass to use these fog settings in preference to the scene settings, whatever they might be. If you specify 'true' but provide no further parameters, you are telling this pass to never use fogging no matter what the scene says. Here is an explanation of the parameters:<BR>
</P>
<DL COMPACT>
<DT>type
<DD><STRONG>none</STRONG> = No fog, equivalent of just using 'fog_override true'<BR>
<STRONG>linear</STRONG> = Linear fog from the &lt;start&gt; and &lt;end&gt; distances<BR>
<STRONG>exp</STRONG> = Fog increases exponentially from the camera (fog = 1/e^(distance * density)), use &lt;density&gt; param to control it<BR>
<STRONG>exp2</STRONG> = Fog increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2), use &lt;density&gt; param to control it
<DT>colour
<DD>	Sequence of 3 floating point values from 0 to 1 indicating the red, green and blue intensities
<DT>density
<DD>	The density parameter used in the 'exp' or 'exp2' fog types. Not used in linear mode but param must still be there as a placeholder
<DT>start
<DD>	The start distance from the camera of linear fog. Must still be present in other modes, even though it is not used.
<DT>end
<DD>	The end distance from the camera of linear fog. Must still be present in other modes, even though it is not used.
</DL>
<BR>
Example: fog_override true exp 1 1 1 0.002 100 10000
<P>

<A NAME="colour_write"></A>
<A NAME="SEC53"></A>
<H3> colour_write </H3>
<!--docid::SEC53::-->
<P>

Sets whether or not this pass renders with colour writing on or not.<BR>
</P>
<P>

Format: colour_write &lt;on|off&gt;<BR><BR>
</P>
<P>

If colour writing is off no visible pixels are written to the screen during this pass. You might think this is useless, but if you render with colour writing off, and with very minimal other settings, you can use this pass to initialise the depth buffer before subsequently rendering other passes which fill in the colour data. This can give you significant performance boosts on some newer cards, especially when using complex fragment programs, because if the depth check fails then the fragment program is never run. <BR><BR>
</P>
<P>

Default: colour_write on<BR>
</P>
<P>

<A NAME="max_lights"></A>
<A NAME="SEC54"></A>
<H3> max_lights </H3>
<!--docid::SEC54::-->
<P>

Sets the maximum number of lights which will be considered for use with this pass.<BR><BR>
Format: max_lights &lt;number&gt;<BR><BR>
</P>
<P>

The maximum number of lights which can be used when rendering fixed-function materials is set by the rendering system, and is typically set at 8. When you are using the programmable pipeline (See section <A HREF="manual_19.html#SEC98">3.1.5 Using Vertex and Fragment Programs in a Pass</A>) this limit is dependent on the program you are running, or, if you use 'iteration once_per_light' (See section <A HREF="manual_16.html#SEC55">iteration</A>), it effectively only bounded by the number of passes you are willing to use. Whichever method you use, however, the max_lights limit applies.<BR><BR>
</P>
<P>

Default: max_lights 8<BR>
</P>
<P>

<A NAME="iteration"></A>
<A NAME="SEC55"></A>
<H3> iteration </H3>
<!--docid::SEC55::-->
<P>

Sets whether or not this pass is iterated, ie issued more than once.<BR><BR>
</P>
<P>

Basic Format: iteration &lt;once | once_per_light&gt; [lightType]<BR><BR>
Advanced Format: iteration &lt;number&gt; [&lt;per_light&gt; [lightType]]<BR><BR>
Examples:
</P>
<DL COMPACT>
<DT>iteration once
<DD>	The pass is only executed once which is the default behaviour.
<DT>iteration once_per_light point
<DD>	The pass is executed once for each point light.
<DT>iteration 5
<DD>	The render state for the pass will be setup and then the draw call will execute 5 times.
<DT>iteration 5 per_light point
<DD>	The render state for the pass will be setup and then the draw call will execute 5 times.  This will be done for each point light.
</DL>
<BR>
<P>

By default, passes are only issued once. However, if you use the programmable pipeline, or you wish to exceed the normal limits on the number of lights which are supported, you might want to use the once_per_light option. In this case, only light index 0 is ever used, and the pass is issued multiple times, each time with a different light in light index 0. Clearly this will make the pass more expensive, but it may be the only way to achieve certain effects such as per-pixel lighting effects which take into account 1..n lights.<BR><BR>
</P>
<P>

Using a number instead of &quot;once&quot; instructs the pass to iterate more than once after the render state is setup.  The render state is not changed after the initial setup so repeated draw calls are very fast and ideal for passes using programmable shaders that must iterate more than once with the same render state ie. shaders that do fur, motion blur, special filtering.<BR><BR>
</P>
<P>

If you use once_per_light, you should also add an ambient pass to the technique before this pass, otherwise when no lights are in range of this object it will not get rendered at all; this is important even when you have no ambient light in the scene, because you would still want the objects sihouette to appear.<BR><BR>
</P>
<P>

The second parameter to the attribute only applies if you use once_per_light or per_light, and restricts the pass to being run for lights of a single type (either 'point', 'directional' or 'spot'). In the example, the pass will be run once per point light. This can be useful because when you're writing a vertex / fragment program it is a lot better if you can assume the kind of lights you'll be dealing with. 
<BR><BR>
Default: iteration once<BR><BR>
</P>
<P>

<A NAME="fur_example"></A>
Example: Simple Fur shader material script that uses a second pass with 10 iterations to grow the fur:
<TABLE><tr><td>&nbsp;</td><td class=example><pre>// GLSL simple Fur
vertex_program GLSLDemo/FurVS glsl 
{ 
  source fur.vert 
  default_params
  {
    param_named_auto lightPosition light_position_object_space 0
    param_named_auto eyePosition camera_position_object_space
    param_named_auto passNumber pass_number
    param_named_auto multiPassNumber pass_iteration_number
    param_named furLength float 0.15
  }
} 

fragment_program GLSLDemo/FurFS glsl 
{ 
  source fur.frag 
  default_params
  {
    param_named Ka float 0.2
    param_named Kd float 0.5
    param_named Ks float 0.0
    param_named furTU int 0
  }
} 

material Fur
{ 
  technique GLSL
  { 
    pass base_coat
    { 
      ambient 0.7 0.7 0.7
      diffuse 0.5 0.8 0.5
      specular 1.0 1.0 1.0 1.5

      vertex_program_ref GLSLDemo/FurVS
      {
      }

      fragment_program_ref GLSLDemo/FurFS 
      { 
      } 

      texture_unit
      {
        texture Fur.tga
        tex_coord_set 0
        filtering trilinear
      }

    } 

    pass grow_fur
    { 
      ambient 0.7 0.7 0.7
      diffuse 0.8 1.0 0.8
      specular 1.0 1.0 1.0 64
      depth_write off

      scene_blend src_alpha one
      iteration 10
      
      vertex_program_ref GLSLDemo/FurVS
      {
      }

      fragment_program_ref GLSLDemo/FurFS
      {
      }

      texture_unit
      {
        texture Fur.tga
        tex_coord_set 0
        filtering trilinear
      }
    } 
  } 
}
</pre></td></tr></table>Note: use gpu program auto parameters  <A HREF="manual_19.html#pass_number">pass_number</A> and  <A HREF="manual_19.html#pass_iteration_number">pass_iteration_number</A> to tell the vertex or fragment program the pass number and iteration number.<BR><BR>
<P>

<A NAME="point_size"></A>
<A NAME="SEC56"></A>
<H3> point_size </H3>
<!--docid::SEC56::-->
<P>

This setting allows you to change the size of points when rendering a point list, or a list of point sprites. The interpretation of this command depends on the <A HREF="manual_16.html#SEC58">point_size_attenuation</A> option - if it is off (the default), the point size is in screen pixels, if it is on, it expressed as normalised screen coordinates (1.0 is the height of the screen) when the point is at the origin.  <BR><BR>
</P>
<P>

NOTE: Some drivers have an upper limit on the size of points they support - this can even vary between APIs on the same card! Don't rely on point sizes that cause the points to get very large on screen, since they may get clamped on some cards. Upper sizes can range from 64 to 256 pixels.<BR><BR>
</P>
<P>

Format: point_size &lt;size&gt;<BR><BR>
Default: point_size 1.0<BR><BR>
</P>
<P>

<A NAME="point_sprites"></A>
<A NAME="SEC57"></A>
<H3> point_sprites </H3>
<!--docid::SEC57::-->
<P>

This setting specifies whether or not hardware point sprite rendering is enabled for this pass. Enabling it means that a point list is rendered as a list of quads rather than a list of dots. It is very useful to use this option if you're using a billboardset and only need to use point oriented billboards which are all of the same size. You can also use it for any other point list render. <BR><BR>
</P>
<P>

Format: point_sprites &lt;on|off&gt;<BR><BR>
Default: point_sprites off<BR><BR>
</P>
<P>

<A NAME="point_size_attenuation"></A>
<A NAME="SEC58"></A>
<H3> point_size_attenuation </H3>
<!--docid::SEC58::-->
<P>

Defines whether point size is attenuated with view space distance, and in what fashion. This option is especially useful when you're using point sprites (See section <A HREF="manual_16.html#SEC57">point_sprites</A>) since it defines how they reduce in size as they get further away from the camera. You can also disable this option to make point sprites a constant screen size (like points), or enable it for points so they change size with distance.<BR><BR>
</P>
<P>

You only have to provide the final 3 parameters if you turn attenuation on. The formula for attenuation is that the size of the point is multiplied by 1 / (constant + linear * dist + quadratic * d^2); therefore turning it off is equivalent to (constant = 1, linear = 0, quadratic = 0) and standard perspective attenuation is (constant = 0, linear = 1, quadratic = 0). The latter is assumed if you leave out the final 3 parameters when you specify 'on'.<BR><BR>
</P>
<P>

Note that the resulting attenuated size is clamped to the minimum and maximum point size, see the next section.<BR><BR>
</P>
<P>

Format: point_size_attenuation &lt;on|off&gt; [constant linear quadratic]
Default: point_size_attenuation off
</P>
<P>

<A NAME="point_size_min"></A>
<A NAME="SEC59"></A>
<H3> point_size_min </H3>
<!--docid::SEC59::-->
<P>

Sets the minimum point size after attenuation (<A HREF="manual_16.html#SEC58">point_size_attenuation</A>). For details on the size metrics, See section <A HREF="manual_16.html#SEC56">point_size</A>.<BR><BR>
</P>
<P>

Format: point_size_min &lt;size&gt;
Default: point_size_min 0
</P>
<P>

<A NAME="point_size_max"></A>
<A NAME="SEC60"></A>
<H3> point_size_max </H3>
<!--docid::SEC60::-->
<P>

Sets the maximum point size after attenuation (<A HREF="manual_16.html#SEC58">point_size_attenuation</A>). For details on the size metrics, See section <A HREF="manual_16.html#SEC56">point_size</A>. A value of 0 means the maximum is set to the same as the max size reported by the current card. <BR><BR>
</P>
<P>

Format: point_size_max &lt;size&gt;
Default: point_size_max 0
</P>
<P>

<A NAME="Texture Units"></A>
<HR SIZE=1>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_15.html#SEC31"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_14.html#SEC23"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_17.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="index.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="manual_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>
<FONT SIZE="-1">
This document was generated
by <I>steve</I> on <I>July 23 2006</I>
using <A HREF="http://texi2html.cvshome.org"><I>texi2html</I></A>
</FONT>

</BODY>
</HTML>
