<html>
<head>
<title>OGRE: Ogre::BspNode Class Reference - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="namespaceOgre.html">Ogre</a>::<a class="el" href="classOgre_1_1BspNode.html">BspNode</a></div>
<h1>Ogre::BspNode Class Reference</h1>Encapsulates a node in a BSP tree.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>&gt;</code>
<p>
<a href="classOgre_1_1BspNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::set&lt; const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">IntersectingObjectSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">NodeBrushList</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea0">BspNode</a> (<a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *owner, bool isLeaf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor, only to be used by <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a>.  <a href="#Ogre_1_1BspNodea0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea1">BspNode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea2">~BspNode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this node is a leaf (i.e.  <a href="#Ogre_1_1BspNodea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea4">getFront</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> containing the subspace on the positive side of the splitting plane.  <a href="#Ogre_1_1BspNodea4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea5">getBack</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> containing the subspace on the negative side of the splitting plane.  <a href="#Ogre_1_1BspNodea5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Plane.html#Ogre_1_1Planew3">Plane::Side</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea6">getSide</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines which side of the splitting plane a worldspace point is.  <a href="#Ogre_1_1BspNodea6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea7">getNextNode</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;point) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the next node down in the tree, with the intention of locating the leaf containing the given point.  <a href="#Ogre_1_1BspNodea7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1Plane.html">Plane</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea8">getSplitPlane</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns details of the plane which is used to subdivide the space of his node's children.  <a href="#Ogre_1_1BspNodea8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea9">getBoundingBox</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the axis-aligned box which contains this node if it is a leaf.  <a href="#Ogre_1_1BspNodea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea10">getNumFaceGroups</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of faces contained in this leaf node.  <a href="#Ogre_1_1BspNodea10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea11">getFaceGroupStart</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the index to the face group index list for this leaf node.  <a href="#Ogre_1_1BspNodea11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea12">isLeafVisible</a> (const <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *leaf) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the passed in node (must also be a leaf) is visible from this leaf.  <a href="#Ogre_1_1BspNodea12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea13">_addMovable</a> (const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mov)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for telling the node that a movable intersects it.  <a href="#Ogre_1_1BspNodea13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea14">_removeMovable</a> (const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *mov)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method for telling the node that a movable no longer intersects it.  <a href="#Ogre_1_1BspNodea14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespaceOgre.html#a465">Real</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea15">getDistance</a> (const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;pos) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the signed distance to the dividing plane.  <a href="#Ogre_1_1BspNodea15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">NodeBrushList</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea16">getSolidBrushes</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the list of solid Brushes for this node.  <a href="#Ogre_1_1BspNodea16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">IntersectingObjectSet</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea17">getObjects</a> (void) const </td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep0">mOwner</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep1">mIsLeaf</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1Plane.html">Plane</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep2">mSplitPlane</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The plane which splits space in a non-leaf node.  <a href="#Ogre_1_1BspNodep2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep3">mFront</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the node in front of this non-leaf node.  <a href="#Ogre_1_1BspNodep3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep4">mBack</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the node behind this non-leaf node.  <a href="#Ogre_1_1BspNodep4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep5">mVisCluster</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The cluster number of this leaf.  <a href="#Ogre_1_1BspNodep5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep6">mBounds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The axis-aligned box which bounds node if it is a leaf.  <a href="#Ogre_1_1BspNodep6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep7">mNumFaceGroups</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of face groups in this node if it is a leaf.  <a href="#Ogre_1_1BspNodep7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep8">mFaceGroupStart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index to the part of the main leaf facegroup index buffer(held in BspLevel) for this leaf.  <a href="#Ogre_1_1BspNodep8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">IntersectingObjectSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep9">mMovables</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">NodeBrushList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep10">mSolidBrushes</a></td></tr>

<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNoden0">BspLevel</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNoden1">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> &amp;n)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Encapsulates a node in a BSP tree. 
<p>
A BSP tree represents space partitioned by planes . The space which is partitioned is either the world (in the case of the root node) or the space derived from their parent node. Each node can have elements which are in front or behind it, which are it's children and these elements can either be further subdivided by planes, or they can be undivided spaces or 'leaf nodes' - these are the nodes which actually contain objects and world geometry.The leaves of the tree are the stopping point of any tree walking algorithm, both for rendering and collision detection etc. <a class="el" href="namespaceOgre.html">Ogre</a> chooses not to represent splitting nodes and leaves as separate structures, but to merge the two for simplicity of the walking algorithm. If a node is a leaf, the <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> method returns true and both <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea4">getFront()</a> and <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea5">getBack()</a> return null pointers. If the node is a partitioning plane <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false and <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea4">getFront()</a> and <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea5">getBack()</a> will return the corresponding <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> objects. 
<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00048">48</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="Ogre_1_1BspNodew0" doxytag="Ogre::BspNode::IntersectingObjectSet"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef std::set&lt;const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a>*&gt; <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">Ogre::BspNode::IntersectingObjectSet</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00142">142</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodew1" doxytag="Ogre::BspNode::NodeBrushList"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef std::vector&lt;<a class="el" href="structOgre_1_1BspNode_1_1Brush.html">Brush</a>*&gt; <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">Ogre::BspNode::NodeBrushList</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00149">149</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="Ogre_1_1BspNodea0" doxytag="Ogre::BspNode::BspNode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Ogre::BspNode::BspNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>owner</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>isLeaf</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor, only to be used by <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a>. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea1" doxytag="Ogre::BspNode::BspNode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Ogre::BspNode::BspNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea2" doxytag="Ogre::BspNode::~BspNode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">Ogre::BspNode::~BspNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="Ogre_1_1BspNodea13" doxytag="Ogre::BspNode::_addMovable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Ogre::BspNode::_addMovable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mov</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Internal method for telling the node that a movable intersects it. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea14" doxytag="Ogre::BspNode::_removeMovable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void Ogre::BspNode::_removeMovable           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1MovableObject.html">MovableObject</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mov</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Internal method for telling the node that a movable no longer intersects it. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea5" doxytag="Ogre::BspNode::getBack"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getBack           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> containing the subspace on the negative side of the splitting plane. 
<p>
This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea9" doxytag="Ogre::BspNode::getBoundingBox"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a>&amp; Ogre::BspNode::getBoundingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the axis-aligned box which contains this node if it is a leaf. 
<p>
This method should only be called on a leaf node. It returns a box which can be used in calls like <a class="el" href="classOgre_1_1Camera.html#Ogre_1_1OctreeCameraa60">Camera::isVisible</a> to determine if the leaf node is visible in the view.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea15" doxytag="Ogre::BspNode::getDistance"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="namespaceOgre.html#a465">Real</a> Ogre::BspNode::getDistance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pos</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the signed distance to the dividing plane. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea11" doxytag="Ogre::BspNode::getFaceGroupStart"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Ogre::BspNode::getFaceGroupStart           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the index to the face group index list for this leaf node. 
<p>
The contents of this buffer is a list of indexes which point to the actual face groups held in a central buffer in the <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> class (in actual fact for efficency the indexes themselves are also held in a single buffer in <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> too). The reason for this indirection is that the buffer of indexes to face groups is organised in chunks relative to nodes, whilst the main buffer of face groups may not be. Should only be called on a leaf node.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea4" doxytag="Ogre::BspNode::getFront"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getFront           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns a pointer to a <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> containing the subspace on the positive side of the splitting plane. 
<p>
This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea7" doxytag="Ogre::BspNode::getNextNode"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* Ogre::BspNode::getNextNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>point</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the next node down in the tree, with the intention of locating the leaf containing the given point. 
<p>
This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea10" doxytag="Ogre::BspNode::getNumFaceGroups"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int Ogre::BspNode::getNumFaceGroups           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the number of faces contained in this leaf node. 
<p>
Should only be called on a leaf node.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea17" doxytag="Ogre::BspNode::getObjects"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">IntersectingObjectSet</a>&amp; Ogre::BspNode::getObjects           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00201">201</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.
<p>
References <a class="el" href="OgreBspNode_8h-source.html#l00197">mMovables</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea6" doxytag="Ogre::BspNode::getSide"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1Plane.html#Ogre_1_1Planew3">Plane::Side</a> Ogre::BspNode::getSide           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1Vector3.html">Vector3</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>point</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines which side of the splitting plane a worldspace point is. 
<p>
This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea16" doxytag="Ogre::BspNode::getSolidBrushes"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">NodeBrushList</a>&amp; Ogre::BspNode::getSolidBrushes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the list of solid Brushes for this node. 
<p>
<dl compact><dt><b>Remarks:</b></dt><dd>Only applicable for leaf nodes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea8" doxytag="Ogre::BspNode::getSplitPlane"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1Plane.html">Plane</a>&amp; Ogre::BspNode::getSplitPlane           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns details of the plane which is used to subdivide the space of his node's children. 
<p>
This method should only be called on a splitting node, i.e. where <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodea3">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea3" doxytag="Ogre::BspNode::isLeaf"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Ogre::BspNode::isLeaf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if this node is a leaf (i.e. 
<p>
contains geometry) or false if it is a splitting plane. A <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> can either be a splitting plane (the typical representation of a BSP node) or an undivided region contining geometry (a leaf node). <a class="el" href="namespaceOgre.html">Ogre</a> represents both using the same class for simplicity of tree walking. However it is important that you use this method to determine which type you are dealing with, since certain methods are only supported with one of the subtypes. Details are given in the individual methods. Note that I could have represented splitting / leaf nodes as a class hierarchy but the virtual methods / run-time type identification would have a performance hit, and it would not make the code much (any?) simpler anyway. I think this is a fair trade-off in this case.     </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodea12" doxytag="Ogre::BspNode::isLeafVisible"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool Ogre::BspNode::isLeafVisible           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="classOgre_1_1BspNode.html">BspNode</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>leaf</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determines if the passed in node (must also be a leaf) is visible from this leaf. 
<p>
Must only be called on a leaf node, and the parameter must also be a leaf node. If this method returns true, then the leaf passed in is visible from this leaf. Note that internally this uses the Potentially Visible Set (PVS) which is precalculated and stored with the BSP level.     </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="Ogre_1_1BspNoden0" doxytag="Ogre::BspNode::BspLevel"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">friend class <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a><code> [friend]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00050">50</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNoden1" doxytag="Ogre::BspNode::operator<<"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">std::ostream&amp; operator&lt;&lt;           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>o</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classOgre_1_1BspNode.html">BspNode</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="Ogre_1_1BspNodep4" doxytag="Ogre::BspNode::mBack"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep4">Ogre::BspNode::mBack</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pointer to the node behind this non-leaf node. 
<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00168">168</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep6" doxytag="Ogre::BspNode::mBounds"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1AxisAlignedBox.html">AxisAlignedBox</a> <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep6">Ogre::BspNode::mBounds</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The axis-aligned box which bounds node if it is a leaf. 
<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00185">185</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep8" doxytag="Ogre::BspNode::mFaceGroupStart"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep8">Ogre::BspNode::mFaceGroupStart</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Index to the part of the main leaf facegroup index buffer(held in BspLevel) for this leaf. 
<p>
This leaf uses mNumFaceGroups from this pointer onwards. From here you use the index in this buffer to look up the actual face. Note that again for simplicity and bulk memory allocation the face group list itself is allocated by the <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> for all nodes, and each leaf node is given a section of it to work on. This saves lots of small memory allocations / deallocations which limits memory fragmentation. 
<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00195">195</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep3" doxytag="Ogre::BspNode::mFront"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html">BspNode</a>* <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep3">Ogre::BspNode::mFront</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pointer to the node in front of this non-leaf node. 
<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00166">166</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep1" doxytag="Ogre::BspNode::mIsLeaf"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep1">Ogre::BspNode::mIsLeaf</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00157">157</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep9" doxytag="Ogre::BspNode::mMovables"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew0">IntersectingObjectSet</a> <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep9">Ogre::BspNode::mMovables</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00197">197</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.
<p>
Referenced by <a class="el" href="OgreBspNode_8h-source.html#l00201">getObjects()</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep7" doxytag="Ogre::BspNode::mNumFaceGroups"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep7">Ogre::BspNode::mNumFaceGroups</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Number of face groups in this node if it is a leaf. 
<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00187">187</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep0" doxytag="Ogre::BspNode::mOwner"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a>* <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep0">Ogre::BspNode::mOwner</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00156">156</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep10" doxytag="Ogre::BspNode::mSolidBrushes"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodew1">NodeBrushList</a> <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep10">Ogre::BspNode::mSolidBrushes</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>

<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00199">199</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep2" doxytag="Ogre::BspNode::mSplitPlane"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classOgre_1_1Plane.html">Plane</a> <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep2">Ogre::BspNode::mSplitPlane</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The plane which splits space in a non-leaf node. 
<p>
Note that nodes do not allocate the memory for other nodes - for simplicity and bulk-allocation of memory the <a class="el" href="classOgre_1_1BspLevel.html">BspLevel</a> is responsible for assigning enough memory for all nodes in one go. 
<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00164">164</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="Ogre_1_1BspNodep5" doxytag="Ogre::BspNode::mVisCluster"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="classOgre_1_1BspNode.html#Ogre_1_1BspNodep5">Ogre::BspNode::mVisCluster</a><code> [protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The cluster number of this leaf. 
<p>
Leaf nodes are assigned to 'clusters' of nodes, which are used to group nodes together for visibility testing. There is a lookup table which is used to determine if one cluster of leaves is visible from another cluster. Whilst it would be possible to expand all this out so that each node had a list of pointers to other visible nodes, this would be very expensive in terms of storage (using the cluster method there is a table which is 1-bit squared per cluster, rounded up to the nearest byte obviously, which uses far less space than 4-bytes per linked node per source node). Of course the limitation here is that you have to each leaf in turn to determine if it is visible rather than just following a list, but since this is only done once per frame this is not such a big overhead. 
<p>
Definition at line <a class="el" href="OgreBspNode_8h-source.html#l00182">182</a> of file <a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a>.    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="OgreBspNode_8h-source.html">OgreBspNode.h</a></ul>
<hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Jul 23 10:11:05 2006
</p>
</body>
</html>
