<html>
<head>
<title>OGRE: OgreRadixSort.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreRadixSort.h</h1><a href="OgreRadixSort_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2005 The OGRE Team</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment">-----------------------------------------------------------------------------</span>
00024 <span class="comment">*/</span>
00025 <span class="preprocessor">#ifndef __RadixSort_H__</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define __RadixSort_H__</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00029 
00030 <span class="keyword">namespace </span>Ogre {
00031 
00078     <span class="keyword">template</span> &lt;<span class="keyword">class</span> TContainer, <span class="keyword">class</span> TContainerValueType, <span class="keyword">typename</span> TCompValueType&gt;
<a name="l00079"></a><a class="code" href="classOgre_1_1RadixSort.html">00079</a>     <span class="keyword">class </span><a class="code" href="classOgre_1_1RadixSort.html">RadixSort</a>
00080     {
00081     <span class="keyword">public</span>:
<a name="l00082"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">00082</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> TContainer::iterator <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">ContainerIter</a>;
00083     <span class="keyword">protected</span>:
<a name="l00086"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">00086</a>         <span class="keywordtype">int</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[4][256];
<a name="l00088"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">00088</a>         <span class="keywordtype">int</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[256];
<a name="l00090"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">00090</a>         <span class="keywordtype">int</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">mSortSize</a>;
<a name="l00092"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">00092</a>         <span class="keywordtype">int</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a>;
00093 
<a name="l00094"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html">00094</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html">SortEntry</a>
00095         {
<a name="l00096"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">00096</a>             TCompValueType <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">key</a>;
<a name="l00097"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">00097</a>             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">ContainerIter</a> <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">iter</a>;
<a name="l00098"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">00098</a>             <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">SortEntry</a>() {}
<a name="l00099"></a><a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya1">00099</a>             <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntrya0">SortEntry</a>(TCompValueType k, <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">ContainerIter</a> it)
00100                 : <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo0">key</a>(k), <a class="code" href="structOgre_1_1RadixSort_1_1SortEntry.html#Ogre_1_1RadixSort_1_1SortEntryo1">iter</a>(it) {}
00101 
00102         };
<a name="l00104"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">00104</a>         std::vector&lt;SortEntry&gt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">mSortArea1</a>;
<a name="l00105"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp5">00105</a>         std::vector&lt;SortEntry&gt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp5">mSortArea2</a>;
<a name="l00106"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">00106</a>         std::vector&lt;SortEntry&gt;* <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a>;
<a name="l00107"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">00107</a>         std::vector&lt;SortEntry&gt;* <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">mDest</a>;
<a name="l00108"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">00108</a>         TContainer <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">mTmpContainer</a>; <span class="comment">// initial copy</span>
00109 
00110 
<a name="l00111"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">00111</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(<span class="keywordtype">int</span> byteIndex)
00112         {
00113             <span class="comment">// Calculate offsets</span>
00114             <span class="comment">// Basically this just leaves gaps for duplicate entries to fill</span>
00115             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[0] = 0;
00116             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 256; ++i)
00117             {
00118                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i-1] + <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i-1];
00119             }
00120 
00121             <span class="comment">// Sort pass</span>
00122             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">mSortSize</a>; ++i)
00123             {
00124                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a>)[i].key);
00125                 (*mDest)[<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[byteVal]++] = (*mSrc)[i];
00126             }
00127 
00128         }
00129         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00130"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">00130</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, T val)
00131         {
00132             <span class="comment">// default is to do normal pass</span>
00133             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(byteIndex);
00134         }
00135         
00136         <span class="comment">// special case signed int</span>
<a name="l00137"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb2">00137</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, <span class="keywordtype">int</span> val)
00138         {
00139             <span class="keywordtype">int</span> numNeg = 0;
00140             <span class="comment">// all negative values are in entries 128+ in most significant byte</span>
00141             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 128; i &lt; 256; ++i)
00142             {
00143                 numNeg += <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i];
00144             }
00145             <span class="comment">// Calculate offsets - positive ones start at the number of negatives</span>
00146             <span class="comment">// do positive numbers</span>
00147             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[0] = numNeg;
00148             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 128; ++i)
00149             {
00150                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i-1] + <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i-1];
00151             }
00152             <span class="comment">// Do negative numbers (must start at zero)</span>
00153             <span class="comment">// No need to invert ordering, already correct (-1 is highest number)</span>
00154             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[128] = 0;
00155             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 129; i &lt; 256; ++i)
00156             {
00157                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i-1] + <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i-1];
00158             }
00159 
00160             <span class="comment">// Sort pass</span>
00161             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">mSortSize</a>; ++i)
00162             {
00163                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a>)[i].key);
00164                 (*mDest)[<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[byteVal]++] = (*mSrc)[i];
00165             }
00166         }
00167         
00168 
00169         <span class="comment">// special case float</span>
<a name="l00170"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb3">00170</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(<span class="keywordtype">int</span> byteIndex, <span class="keywordtype">float</span> val)
00171         {
00172             <span class="comment">// floats need to be special cased since negative numbers will come</span>
00173             <span class="comment">// after positives (high bit = sign) and will be in reverse order</span>
00174             <span class="comment">// (no ones-complement of the +ve value)</span>
00175             <span class="keywordtype">int</span> numNeg = 0;
00176             <span class="comment">// all negative values are in entries 128+ in most significant byte</span>
00177             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 128; i &lt; 256; ++i)
00178             {
00179                 numNeg += <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i];
00180             }
00181             <span class="comment">// Calculate offsets - positive ones start at the number of negatives</span>
00182             <span class="comment">// do positive numbers normally</span>
00183             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[0] = numNeg;
00184             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 128; ++i)
00185             {
00186                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i-1] + <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i-1];
00187             }
00188             <span class="comment">// Do negative numbers (must start at zero)</span>
00189             <span class="comment">// Also need to invert ordering</span>
00190             <span class="comment">// In order to preserve the stability of the sort (essential since</span>
00191             <span class="comment">// we rely on previous bytes already being sorted) we have to count</span>
00192             <span class="comment">// backwards in our offsets from </span>
00193             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[255] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][255];
00194             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 254; i &gt; 127; --i)
00195             {
00196                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i] = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[i+1] + <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[byteIndex][i];
00197             }
00198 
00199             <span class="comment">// Sort pass</span>
00200             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">mSortSize</a>; ++i)
00201             {
00202                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(byteIndex, (*<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a>)[i].key);
00203                 <span class="keywordflow">if</span> (byteVal &gt; 127)
00204                 {
00205                     <span class="comment">// -ve; pre-decrement since offsets set to count</span>
00206                     (*mDest)[--<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[byteVal]] = (*mSrc)[i];
00207                 }
00208                 <span class="keywordflow">else</span>
00209                 {
00210                     <span class="comment">// +ve</span>
00211                     (*mDest)[<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp1">mOffsets</a>[byteVal]++] = (*mSrc)[i];
00212                 }
00213             }
00214         }
00215 
<a name="l00216"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">00216</a>         <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(<span class="keywordtype">int</span> byteIndex, TCompValueType val)
00217         {
00218 <span class="preprocessor">#if OGRE_ENDIAN == OGRE_ENDIAN_LITTLE</span>
00219 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(&amp;val))[byteIndex];
00220 <span class="preprocessor">#else</span>
00221 <span class="preprocessor"></span>            <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(&amp;val))[<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a> - byteIndex - 1];
00222 <span class="preprocessor">#endif</span>
00223 <span class="preprocessor"></span>        }
00224 
00225     <span class="keyword">public</span>:
00226 
<a name="l00227"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta0">00227</a>         <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta0">RadixSort</a>() {}
<a name="l00228"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta1">00228</a>         <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta1">~RadixSort</a>() {}
00229 
00235         <span class="keyword">template</span> &lt;<span class="keyword">class</span> TFunction&gt;
<a name="l00236"></a><a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta2">00236</a>         <span class="keywordtype">void</span> <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSorta2">sort</a>(TContainer&amp; container, TFunction func)
00237         {
00238             <span class="keywordflow">if</span> (container.empty())
00239                 <span class="keywordflow">return</span>;
00240 
00241             <span class="comment">// Set up the sort areas</span>
00242             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp2">mSortSize</a> = static_cast&lt;int&gt;(container.size());
00243             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">mSortArea1</a>.resize(container.size());
00244             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp5">mSortArea2</a>.resize(container.size());
00245 
00246             <span class="comment">// Copy data now (we need constant iterators for sorting)</span>
00247             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">mTmpContainer</a> = container;
00248 
00249             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a> = <span class="keyword">sizeof</span>(TCompValueType);
00250 
00251             <span class="comment">// Counter pass</span>
00252             <span class="comment">// Initialise the counts</span>
00253             <span class="keywordtype">int</span> p;
00254             <span class="keywordflow">for</span> (p = 0; p &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a>; ++p)
00255                 memset(<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[p], 0, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * 256);
00256 
00257             <span class="comment">// Perform alpha pass to count</span>
00258             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortw0">ContainerIter</a> i = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">mTmpContainer</a>.begin();
00259             TCompValueType prevValue = func.operator()(*i); 
00260             <span class="keywordtype">bool</span> needsSorting = <span class="keyword">false</span>;
00261             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> u = 0; i != <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp8">mTmpContainer</a>.end(); ++i, ++u)
00262             {
00263                 <span class="comment">// get sort value</span>
00264                 TCompValueType val = func.operator()(*i);
00265                 <span class="comment">// cheap check to see if needs sorting (temporal coherence)</span>
00266                 <span class="keywordflow">if</span> (!needsSorting &amp;&amp; val &lt; prevValue)
00267                     needsSorting = <span class="keyword">true</span>;
00268 
00269                 <span class="comment">// Create a sort entry</span>
00270                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">mSortArea1</a>[u].key = val;
00271                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">mSortArea1</a>[u].iter = i;
00272 
00273                 <span class="comment">// increase counters</span>
00274                 <span class="keywordflow">for</span> (p = 0; p &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a>; ++p)
00275                 {
00276                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> byteVal = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb4">getByte</a>(p, val);
00277                     <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp0">mCounters</a>[p][byteVal]++;
00278                 }
00279 
00280                 prevValue = val;
00281 
00282             }
00283 
00284             <span class="comment">// early exit if already sorted</span>
00285             <span class="keywordflow">if</span> (!needsSorting)
00286                 <span class="keywordflow">return</span>;
00287 
00288 
00289             <span class="comment">// Sort passes</span>
00290             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a> = &amp;<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp4">mSortArea1</a>;
00291             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">mDest</a> = &amp;<a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp5">mSortArea2</a>;
00292 
00293             <span class="keywordflow">for</span> (p = 0; p &lt; <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp3">mNumPasses</a> - 1; ++p)
00294             {
00295                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb0">sortPass</a>(p);
00296                 <span class="comment">// flip src/dst</span>
00297                 std::vector&lt;SortEntry&gt;* tmp = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a>;
00298                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp6">mSrc</a> = <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">mDest</a>;
00299                 <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortp7">mDest</a> = tmp;
00300             }
00301             <span class="comment">// Final pass may differ, make polymorphic</span>
00302             <a class="code" href="classOgre_1_1RadixSort.html#Ogre_1_1RadixSortb1">finalPass</a>(p, prevValue);
00303 
00304             <span class="comment">// Copy everything back</span>
00305             <span class="keywordtype">int</span> c = 0;
00306             <span class="keywordflow">for</span> (i = container.begin(); 
00307                 i != container.end(); ++i, ++c)
00308             {
00309                 *i = *((*mDest)[c].iter);
00310             }
00311         }
00312 
00313     };
00314 
00315 
00316 }
00317 <span class="preprocessor">#endif</span>
00318 <span class="preprocessor"></span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Jul 23 10:05:40 2006
</p>
</body>
</html>
