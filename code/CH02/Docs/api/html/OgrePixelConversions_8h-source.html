<html>
<head>
<title>OGRE: OgrePixelConversions.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000030.html">src</a></div>
<h1>OgrePixelConversions.h</h1><a href="OgrePixelConversions_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001  <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2005 The OGRE Team</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment">-----------------------------------------------------------------------------</span>
00024 <span class="comment">*/</span>
00026 <span class="keyword">using</span> <span class="keyword">namespace </span>Ogre;
00027 
00028 <span class="comment">// NB VC6 can't handle these templates</span>
00029 <span class="preprocessor">#if OGRE_COMPILER != OGRE_COMPILER_MSVC || OGRE_COMP_VER &gt;= 1300</span>
00030 <span class="preprocessor"></span>
00031 <span class="preprocessor">#define FMTCONVERTERID(from,to) (((from)&lt;&lt;8)|(to))</span>
00032 <span class="preprocessor"></span>
00043 <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">struct </span>PixelBoxConverter 
00044 {
00045     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ID = U::ID;
00046     <span class="keyword">static</span> <span class="keywordtype">void</span> conversion(<span class="keyword">const</span> <a class="code" href="classOgre_1_1PixelBox.html">PixelBox</a> &amp;src, <span class="keyword">const</span> <a class="code" href="classOgre_1_1PixelBox.html">PixelBox</a> &amp;dst)
00047     {
00048         <span class="keyword">typename</span> U::SrcType *srcptr = static_cast&lt;typename U::SrcType*&gt;(src.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo0">data</a>);
00049         <span class="keyword">typename</span> U::DstType *dstptr = static_cast&lt;typename U::DstType*&gt;(dst.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo0">data</a>);
00050         <span class="keyword">const</span> size_t srcSliceSkip = src.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxa5">getSliceSkip</a>();
00051         <span class="keyword">const</span> size_t dstSliceSkip = dst.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxa5">getSliceSkip</a>();
00052         <span class="keyword">const</span> size_t k = src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo6">right</a> - src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo4">left</a>;
00053         <span class="keywordflow">for</span>(size_t z=src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo8">front</a>; z&lt;src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo9">back</a>; z++) 
00054         {
00055             <span class="keywordflow">for</span>(size_t y=src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo5">top</a>; y&lt;src.<a class="code" href="structOgre_1_1Box.html#Ogre_1_1PixelBoxo7">bottom</a>; y++)
00056             {
00057                 <span class="keywordflow">for</span>(size_t x=0; x&lt;k; x++)
00058                 {
00059                     dstptr[x] = U::pixelConvert(srcptr[x]);
00060                 }
00061                 srcptr += src.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo2">rowPitch</a>;
00062                 dstptr += dst.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo2">rowPitch</a>;
00063             }
00064             srcptr += srcSliceSkip;
00065             dstptr += dstSliceSkip;
00066         }    
00067     }
00068 };
00069 
00070 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U, <span class="keywordtype">int</span> <span class="keywordtype">id</span>&gt; <span class="keyword">struct </span>PixelConverter {
00071     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> ID = id;
00072     <span class="keyword">typedef</span> T SrcType;
00073     <span class="keyword">typedef</span> U DstType;    
00074     
00075     <span class="comment">//inline static DstType pixelConvert(const SrcType &amp;inp);</span>
00076 };
00077 
00078 
00080 <span class="keyword">struct </span>Col3b {
00081     Col3b(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c): 
00082         x((<a class="code" href="namespaceOgre.html#a457">uint8</a>)a), y((<a class="code" href="namespaceOgre.html#a457">uint8</a>)b), z((<a class="code" href="namespaceOgre.html#a457">uint8</a>)c) { }
00083     <a class="code" href="namespaceOgre.html#a457">uint8</a> x,y,z;
00084 };
00086 <span class="keyword">struct </span>Col3f {
00087     Col3f(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b):
00088         r(r), g(g), b(b) { }
00089     <span class="keywordtype">float</span> r,g,b;
00090 };
00092 <span class="keyword">struct </span>Col4f {
00093     Col4f(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b, <span class="keywordtype">float</span> a):
00094         r(r), g(g), b(b), a(a) { }
00095     <span class="keywordtype">float</span> r,g,b,a;
00096 };
00097 
00098 <span class="keyword">struct </span>A8R8G8B8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8R8G8B8, PF_A8B8G8R8)&gt;
00099 {
00100     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00101     {
00102         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;16)|(inp&amp;0xFF00FF00)|((inp&amp;0x00FF0000)&gt;&gt;16);
00103     }
00104 };
00105 
00106 <span class="keyword">struct </span>A8R8G8B8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8R8G8B8, PF_B8G8R8A8)&gt;
00107 {
00108     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00109     {
00110         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0x0000FF00)&lt;&lt;8)|((inp&amp;0x00FF0000)&gt;&gt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00111     }
00112 };
00113 
00114 <span class="keyword">struct </span>A8R8G8B8toR8G8B8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8R8G8B8, PF_R8G8B8A8)&gt;
00115 {
00116     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00117     {
00118         <span class="keywordflow">return</span> ((inp&amp;0x00FFFFFF)&lt;&lt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00119     }
00120 };
00121 
00122 <span class="keyword">struct </span>A8B8G8R8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8B8G8R8, PF_A8R8G8B8)&gt;
00123 {
00124     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00125     {
00126         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;16)|(inp&amp;0xFF00FF00)|((inp&amp;0x00FF0000)&gt;&gt;16);
00127     }
00128 };
00129 
00130 <span class="keyword">struct </span>A8B8G8R8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8B8G8R8, PF_B8G8R8A8)&gt;
00131 {
00132     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00133     {
00134         <span class="keywordflow">return</span> ((inp&amp;0x00FFFFFF)&lt;&lt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00135     }
00136 };
00137 
00138 <span class="keyword">struct </span>A8B8G8R8toR8G8B8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_A8B8G8R8, PF_R8G8B8A8)&gt;
00139 {
00140     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00141     {
00142         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0x0000FF00)&lt;&lt;8)|((inp&amp;0x00FF0000)&gt;&gt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00143     }
00144 };
00145 
00146 <span class="keyword">struct </span>B8G8R8A8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_B8G8R8A8, PF_A8R8G8B8)&gt;
00147 {
00148     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00149     {
00150         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0x0000FF00)&lt;&lt;8)|((inp&amp;0x00FF0000)&gt;&gt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00151     }
00152 };
00153 
00154 <span class="keyword">struct </span>B8G8R8A8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_B8G8R8A8, PF_A8B8G8R8)&gt;
00155 {
00156     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00157     {
00158         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0xFFFFFF00)&gt;&gt;8);
00159     }
00160 };
00161 
00162 <span class="keyword">struct </span>B8G8R8A8toR8G8B8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_B8G8R8A8, PF_R8G8B8A8)&gt;
00163 {
00164     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00165     {
00166         <span class="keywordflow">return</span> ((inp&amp;0x0000FF00)&lt;&lt;16)|(inp&amp;0x00FF00FF)|((inp&amp;0xFF000000)&gt;&gt;16);
00167     }
00168 };
00169 
00170 <span class="keyword">struct </span>R8G8B8A8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_R8G8B8A8, PF_A8R8G8B8)&gt;
00171 {
00172     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00173     {
00174         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0xFFFFFF00)&gt;&gt;8);
00175     }
00176 };
00177 
00178 <span class="keyword">struct </span>R8G8B8A8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_R8G8B8A8, PF_A8B8G8R8)&gt;
00179 {
00180     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00181     {
00182         <span class="keywordflow">return</span> ((inp&amp;0x000000FF)&lt;&lt;24)|((inp&amp;0x0000FF00)&lt;&lt;8)|((inp&amp;0x00FF0000)&gt;&gt;8)|((inp&amp;0xFF000000)&gt;&gt;24);
00183     }
00184 };
00185 
00186 <span class="keyword">struct </span>R8G8B8A8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_R8G8B8A8, PF_B8G8R8A8)&gt;
00187 {
00188     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00189     {
00190         <span class="keywordflow">return</span> ((inp&amp;0x0000FF00)&lt;&lt;16)|(inp&amp;0x00FF00FF)|((inp&amp;0xFF000000)&gt;&gt;16);
00191     }
00192 };
00193 
00194 <span class="keyword">struct </span>A8B8G8R8toL8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint8, FMTCONVERTERID(PF_A8B8G8R8, PF_L8)&gt;
00195 {
00196     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00197     {
00198         <span class="keywordflow">return</span> (<a class="code" href="namespaceOgre.html#a457">uint8</a>)(inp&amp;0x000000FF);
00199     }
00200 };
00201 
00202 <span class="keyword">struct </span>L8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint8, uint32, FMTCONVERTERID(PF_L8, PF_A8B8G8R8)&gt;
00203 {
00204     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00205     {
00206         <span class="keywordflow">return</span> 0xFF000000|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;0)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;8)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;16);
00207     }
00208 };
00209 
00210 <span class="keyword">struct </span>A8R8G8B8toL8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint8, FMTCONVERTERID(PF_A8R8G8B8, PF_L8)&gt;
00211 {
00212     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00213     {
00214         <span class="keywordflow">return</span> (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&amp;0x00FF0000)&gt;&gt;16);
00215     }
00216 };
00217 
00218 <span class="keyword">struct </span>L8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint8, uint32, FMTCONVERTERID(PF_L8, PF_A8R8G8B8)&gt;
00219 {
00220     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00221     {
00222         <span class="keywordflow">return</span> 0xFF000000|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;0)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;8)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;16);
00223     }
00224 };
00225 
00226 <span class="keyword">struct </span>B8G8R8A8toL8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint8, FMTCONVERTERID(PF_B8G8R8A8, PF_L8)&gt;
00227 {
00228     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00229     {
00230         <span class="keywordflow">return</span> (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&amp;0x0000FF00)&gt;&gt;8);
00231     }
00232 };
00233 
00234 <span class="keyword">struct </span>L8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint8, uint32, FMTCONVERTERID(PF_L8, PF_B8G8R8A8)&gt;
00235 {
00236     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00237     {
00238         <span class="keywordflow">return</span> 0x000000FF|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;8)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;16)|(((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;24);
00239     }
00240 };
00241 
00242 <span class="keyword">struct </span>L8toL16: <span class="keyword">public</span> PixelConverter &lt;uint8, uint16, FMTCONVERTERID(PF_L8, PF_L16)&gt;
00243 {
00244     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00245     {
00246         <span class="keywordflow">return</span> (<a class="code" href="namespaceOgre.html#a456">uint16</a>)((((<span class="keywordtype">unsigned</span> int)inp)&lt;&lt;8)|(((<span class="keywordtype">unsigned</span> int)inp)));
00247     }
00248 };
00249 
00250 <span class="keyword">struct </span>L16toL8: <span class="keyword">public</span> PixelConverter &lt;uint16, uint8, FMTCONVERTERID(PF_L16, PF_L8)&gt;
00251 {
00252     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00253     {
00254         <span class="keywordflow">return</span> (<a class="code" href="namespaceOgre.html#a457">uint8</a>)(inp&gt;&gt;8);
00255     }
00256 };
00257 
00258 <span class="keyword">struct </span>R8G8B8toB8G8R8: <span class="keyword">public</span> PixelConverter &lt;Col3b, Col3b, FMTCONVERTERID(PF_R8G8B8, PF_B8G8R8)&gt;
00259 {
00260     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(<span class="keyword">const</span> SrcType &amp;inp)
00261     {
00262         <span class="keywordflow">return</span> Col3b(inp.z, inp.y, inp.x);
00263     }  
00264 };
00265 
00266 <span class="keyword">struct </span>B8G8R8toR8G8B8: <span class="keyword">public</span> PixelConverter &lt;Col3b, Col3b, FMTCONVERTERID(PF_B8G8R8, PF_R8G8B8)&gt;
00267 {
00268     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(<span class="keyword">const</span> SrcType &amp;inp)
00269     {
00270         <span class="keywordflow">return</span> Col3b(inp.z, inp.y, inp.x);
00271     }  
00272 };
00273 
00274 <span class="comment">// X8Y8Z8 -&gt;  X8&lt;&lt;xshift Y8&lt;&lt;yshift Z8&lt;&lt;zshift A8&lt;&lt;ashift</span>
00275 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xshift, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yshift, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zshift, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ashift&gt; <span class="keyword">struct </span>Col3btoUint32swizzler:
00276     <span class="keyword">public</span> PixelConverter &lt;Col3b, uint32, id&gt;
00277 {
00278     <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="namespaceOgre.html#a455">uint32</a> pixelConvert(<span class="keyword">const</span> Col3b &amp;inp)
00279     {
00280 <span class="preprocessor">#if OGRE_ENDIAN == OGRE_ENDIAN_BIG</span>
00281 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (0xFF&lt;&lt;ashift) | (((<span class="keywordtype">unsigned</span> int)inp.x)&lt;&lt;xshift) | (((<span class="keywordtype">unsigned</span> int)inp.y)&lt;&lt;yshift) | (((<span class="keywordtype">unsigned</span> int)inp.z)&lt;&lt;zshift);
00282 <span class="preprocessor">#else</span>
00283 <span class="preprocessor"></span>        <span class="keywordflow">return</span> (0xFF&lt;&lt;ashift) | (((<span class="keywordtype">unsigned</span> int)inp.x)&lt;&lt;zshift) | (((<span class="keywordtype">unsigned</span> int)inp.y)&lt;&lt;yshift) | (((<span class="keywordtype">unsigned</span> int)inp.z)&lt;&lt;xshift);
00284 <span class="preprocessor">#endif</span>
00285 <span class="preprocessor"></span>    }
00286 };
00287 
00288 <span class="keyword">struct </span>R8G8B8toA8R8G8B8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_R8G8B8, PF_A8R8G8B8), 16, 8, 0, 24&gt; { };
00289 <span class="keyword">struct </span>B8G8R8toA8R8G8B8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_B8G8R8, PF_A8R8G8B8), 0, 8, 16, 24&gt; { };
00290 <span class="keyword">struct </span>R8G8B8toA8B8G8R8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_R8G8B8, PF_A8B8G8R8), 0, 8, 16, 24&gt; { };
00291 <span class="keyword">struct </span>B8G8R8toA8B8G8R8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_B8G8R8, PF_A8B8G8R8), 16, 8, 0, 24&gt; { };
00292 <span class="keyword">struct </span>R8G8B8toB8G8R8A8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_R8G8B8, PF_B8G8R8A8), 8, 16, 24, 0&gt; { };
00293 <span class="keyword">struct </span>B8G8R8toB8G8R8A8: <span class="keyword">public</span> Col3btoUint32swizzler&lt;FMTCONVERTERID(PF_B8G8R8, PF_B8G8R8A8), 24, 16, 8, 0&gt; { };
00294 
00295 <span class="keyword">struct </span>A8R8G8B8toR8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, Col3b, FMTCONVERTERID(PF_A8R8G8B8, PF_BYTE_RGB)&gt;
00296 {
00297     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(<a class="code" href="namespaceOgre.html#a455">uint32</a> inp)
00298     {
00299         <span class="keywordflow">return</span> Col3b((<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;16)&amp;0xFF), (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;8)&amp;0xFF), (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;0)&amp;0xFF));
00300     }
00301 };
00302 <span class="keyword">struct </span>A8R8G8B8toB8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, Col3b, FMTCONVERTERID(PF_A8R8G8B8, PF_BYTE_BGR)&gt;
00303 {
00304     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(<a class="code" href="namespaceOgre.html#a455">uint32</a> inp)
00305     {
00306         <span class="keywordflow">return</span> Col3b((<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;0)&amp;0xFF), (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;8)&amp;0xFF), (<a class="code" href="namespaceOgre.html#a457">uint8</a>)((inp&gt;&gt;16)&amp;0xFF));
00307     }
00308 };
00309 
00310 <span class="comment">// Only conversions from X8R8G8B8 to formats with alpha need to be defined, the rest is implicitly the same</span>
00311 <span class="comment">// as A8R8G8B8</span>
00312 <span class="keyword">struct </span>X8R8G8B8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8R8G8B8, PF_A8R8G8B8)&gt;
00313 {
00314     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00315     {
00316         <span class="keywordflow">return</span> inp | 0xFF000000;
00317     }
00318 };
00319 <span class="keyword">struct </span>X8R8G8B8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8R8G8B8, PF_A8B8G8R8)&gt;
00320 {
00321     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00322     {
00323         <span class="keywordflow">return</span> ((inp&amp;0x0000FF)&lt;&lt;16)|((inp&amp;0xFF0000)&gt;&gt;16)|(inp&amp;0x00FF00)|0xFF000000;
00324     }
00325 };
00326 <span class="keyword">struct </span>X8R8G8B8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8R8G8B8, PF_B8G8R8A8)&gt;
00327 {
00328     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00329     {
00330         <span class="keywordflow">return</span> ((inp&amp;0x0000FF)&lt;&lt;24)|((inp&amp;0xFF0000)&gt;&gt;8)|((inp&amp;0x00FF00)&lt;&lt;8)|0x000000FF;
00331     }
00332 };
00333 <span class="keyword">struct </span>X8R8G8B8toR8G8B8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8R8G8B8, PF_R8G8B8A8)&gt;
00334 {
00335     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00336     {
00337         <span class="keywordflow">return</span> ((inp&amp;0xFFFFFF)&lt;&lt;8)|0x000000FF;
00338     }
00339 };
00340 
00341 <span class="comment">// X8B8G8R8</span>
00342 <span class="keyword">struct </span>X8B8G8R8toA8R8G8B8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8B8G8R8, PF_A8R8G8B8)&gt;
00343 {
00344     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00345     {
00346         <span class="keywordflow">return</span> ((inp&amp;0x0000FF)&lt;&lt;16)|((inp&amp;0xFF0000)&gt;&gt;16)|(inp&amp;0x00FF00)|0xFF000000;
00347     }
00348 };
00349 <span class="keyword">struct </span>X8B8G8R8toA8B8G8R8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8B8G8R8, PF_A8B8G8R8)&gt;
00350 {
00351     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00352     {
00353         <span class="keywordflow">return</span> inp | 0xFF000000;
00354     }
00355 };
00356 <span class="keyword">struct </span>X8B8G8R8toB8G8R8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8B8G8R8, PF_B8G8R8A8)&gt;
00357 {
00358     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00359     {
00360         <span class="keywordflow">return</span> ((inp&amp;0xFFFFFF)&lt;&lt;8)|0x000000FF;
00361     }
00362 };
00363 <span class="keyword">struct </span>X8B8G8R8toR8G8B8A8: <span class="keyword">public</span> PixelConverter &lt;uint32, uint32, FMTCONVERTERID(PF_X8B8G8R8, PF_R8G8B8A8)&gt;
00364 {
00365     <span class="keyword">inline</span> <span class="keyword">static</span> DstType pixelConvert(SrcType inp)
00366     {
00367         <span class="keywordflow">return</span> ((inp&amp;0x0000FF)&lt;&lt;24)|((inp&amp;0xFF0000)&gt;&gt;8)|((inp&amp;0x00FF00)&lt;&lt;8)|0x000000FF;
00368     }
00369 };
00370 
00371 
00372 <span class="preprocessor">#define CASECONVERTER(type) case type::ID : PixelBoxConverter&lt;type&gt;::conversion(src, dst); return 1;</span>
00373 <span class="preprocessor"></span>
00374 <span class="keyword">inline</span> <span class="keywordtype">int</span> doOptimizedConversion(<span class="keyword">const</span> <a class="code" href="classOgre_1_1PixelBox.html">PixelBox</a> &amp;src, <span class="keyword">const</span> <a class="code" href="classOgre_1_1PixelBox.html">PixelBox</a> &amp;dst)
00375 {;
00376     <span class="keywordflow">switch</span>(FMTCONVERTERID(src.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo1">format</a>, dst.<a class="code" href="classOgre_1_1PixelBox.html#Ogre_1_1PixelBoxo1">format</a>))
00377     {
00378         <span class="comment">// Register converters here</span>
00379         CASECONVERTER(A8R8G8B8toA8B8G8R8);
00380         CASECONVERTER(A8R8G8B8toB8G8R8A8);
00381         CASECONVERTER(A8R8G8B8toR8G8B8A8);
00382         CASECONVERTER(A8B8G8R8toA8R8G8B8);
00383         CASECONVERTER(A8B8G8R8toB8G8R8A8);
00384         CASECONVERTER(A8B8G8R8toR8G8B8A8);
00385         CASECONVERTER(B8G8R8A8toA8R8G8B8);
00386         CASECONVERTER(B8G8R8A8toA8B8G8R8);
00387         CASECONVERTER(B8G8R8A8toR8G8B8A8);
00388         CASECONVERTER(R8G8B8A8toA8R8G8B8);
00389         CASECONVERTER(R8G8B8A8toA8B8G8R8);
00390         CASECONVERTER(R8G8B8A8toB8G8R8A8);
00391         CASECONVERTER(A8B8G8R8toL8);
00392         CASECONVERTER(L8toA8B8G8R8);
00393         CASECONVERTER(A8R8G8B8toL8);
00394         CASECONVERTER(L8toA8R8G8B8);
00395         CASECONVERTER(B8G8R8A8toL8);
00396         CASECONVERTER(L8toB8G8R8A8);
00397         CASECONVERTER(L8toL16);
00398         CASECONVERTER(L16toL8);
00399         CASECONVERTER(B8G8R8toR8G8B8);
00400         CASECONVERTER(R8G8B8toB8G8R8);
00401         CASECONVERTER(R8G8B8toA8R8G8B8);
00402         CASECONVERTER(B8G8R8toA8R8G8B8);
00403         CASECONVERTER(R8G8B8toA8B8G8R8);
00404         CASECONVERTER(B8G8R8toA8B8G8R8);
00405         CASECONVERTER(R8G8B8toB8G8R8A8);
00406         CASECONVERTER(B8G8R8toB8G8R8A8);
00407         CASECONVERTER(A8R8G8B8toR8G8B8);
00408         CASECONVERTER(A8R8G8B8toB8G8R8);
00409         CASECONVERTER(X8R8G8B8toA8R8G8B8);
00410         CASECONVERTER(X8R8G8B8toA8B8G8R8);
00411         CASECONVERTER(X8R8G8B8toB8G8R8A8);
00412         CASECONVERTER(X8R8G8B8toR8G8B8A8);
00413         CASECONVERTER(X8B8G8R8toA8R8G8B8);
00414         CASECONVERTER(X8B8G8R8toA8B8G8R8);
00415         CASECONVERTER(X8B8G8R8toB8G8R8A8);
00416         CASECONVERTER(X8B8G8R8toR8G8B8A8);
00417 
00418         <span class="keywordflow">default</span>:
00419             <span class="keywordflow">return</span> 0;
00420     }
00421 }
00422 <span class="preprocessor">#undef CASECONVERTER</span>
00423 <span class="preprocessor"></span>
00424 <span class="preprocessor">#endif // VC6 protection</span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Jul 23 10:05:39 2006
</p>
</body>
</html>
