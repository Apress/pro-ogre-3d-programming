<html>
<head>
<title>OGRE: OgreHardwareBuffer.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreHardwareBuffer.h</h1><a href="OgreHardwareBuffer_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2005 The OGRE Team</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU Lesser General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU Lesser General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/lesser.txt.</span>
00023 <span class="comment">-----------------------------------------------------------------------------</span>
00024 <span class="comment">*/</span>
00025 <span class="preprocessor">#ifndef __HardwareBuffer__</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define __HardwareBuffer__</span>
00027 <span class="preprocessor"></span>
00028 <span class="comment">// Precompiler options</span>
00029 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00030 
00031 <span class="keyword">namespace </span>Ogre {
00032 
<a name="l00064"></a><a class="code" href="classOgre_1_1HardwareBuffer.html">00064</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a16">_OgreExport</a> HardwareBuffer 
00065     {
00066 
00067         <span class="keyword">public</span>:
<a name="l00069"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferw11">00069</a>             <span class="keyword">enum</span> Usage 
00070             {
00074                 HBU_STATIC = 1,
00080                 HBU_DYNAMIC = 2,
00087                 HBU_WRITE_ONLY = 4,
00096                 HBU_DISCARDABLE = 8,
00098                 HBU_STATIC_WRITE_ONLY = 5, 
00104                 HBU_DYNAMIC_WRITE_ONLY = 6,
00106                 HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE = 14
00107 
00108 
00109             };
<a name="l00111"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferw12">00111</a>             <span class="keyword">enum</span> LockOptions
00112             {
00114                 HBL_NORMAL,
00119                 HBL_DISCARD,
00123                 HBL_READ_ONLY,
00127                 HBL_NO_OVERWRITE
00128                 
00129             };
00130         <span class="keyword">protected</span>:
<a name="l00131"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp2">00131</a>             size_t mSizeInBytes;
<a name="l00132"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp3">00132</a>             Usage mUsage;
<a name="l00133"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp4">00133</a>             <span class="keywordtype">bool</span> mIsLocked;
<a name="l00134"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp5">00134</a>             size_t mLockStart;
<a name="l00135"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp6">00135</a>             size_t mLockSize;
<a name="l00136"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp7">00136</a>             <span class="keywordtype">bool</span> mSystemMemory;
<a name="l00137"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp8">00137</a>             <span class="keywordtype">bool</span> mUseShadowBuffer;
<a name="l00138"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp9">00138</a>             HardwareBuffer* mpShadowBuffer;
<a name="l00139"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp10">00139</a>             <span class="keywordtype">bool</span> mShadowUpdated;
<a name="l00140"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBufferp11">00140</a>             <span class="keywordtype">bool</span> mSuppressHardwareUpdate;
00141             
00143             <span class="keyword">virtual</span> <span class="keywordtype">void</span>* lockImpl(size_t offset, size_t length, LockOptions options) = 0;
00145             <span class="keyword">virtual</span> <span class="keywordtype">void</span> unlockImpl(<span class="keywordtype">void</span>) = 0;
00146 
00147     <span class="keyword">public</span>:
<a name="l00149"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareBuffera0">00149</a>             HardwareBuffer(Usage usage, <span class="keywordtype">bool</span> systemMemory, <span class="keywordtype">bool</span> useShadowBuffer) 
00150                 : mUsage(usage), mIsLocked(false), mSystemMemory(systemMemory), 
00151                 mUseShadowBuffer(useShadowBuffer), mpShadowBuffer(NULL), mShadowUpdated(false), 
00152                 mSuppressHardwareUpdate(false) 
00153             {
00154                 <span class="comment">// If use shadow buffer, upgrade to WRITE_ONLY on hardware side</span>
00155                 <span class="keywordflow">if</span> (useShadowBuffer &amp;&amp; usage == HBU_DYNAMIC)
00156                 {
00157                     mUsage = HBU_DYNAMIC_WRITE_ONLY;
00158                 }
00159                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (useShadowBuffer &amp;&amp; usage == HBU_STATIC)
00160                 {
00161                     mUsage = HBU_STATIC_WRITE_ONLY;
00162                 }
00163             }
<a name="l00164"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareBuffera1">00164</a>             <span class="keyword">virtual</span> ~HardwareBuffer() {}
<a name="l00171"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera4">00171</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span>* lock(size_t offset, size_t length, LockOptions options)
00172             {
00173                 assert(!isLocked() &amp;&amp; <span class="stringliteral">"Cannot lock this buffer, it is already locked!"</span>);
00174                 <span class="keywordtype">void</span>* ret;
00175                 <span class="keywordflow">if</span> (mUseShadowBuffer)
00176                 {
00177                     <span class="keywordflow">if</span> (options != HBL_READ_ONLY)
00178                     {
00179                         <span class="comment">// we have to assume a read / write lock so we use the shadow buffer</span>
00180                         <span class="comment">// and tag for sync on unlock()</span>
00181                         mShadowUpdated = <span class="keyword">true</span>;
00182                     }
00183 
00184                     ret = mpShadowBuffer-&gt;lock(offset, length, options);
00185                 }
00186                 <span class="keywordflow">else</span>
00187                 {
00188                     <span class="comment">// Lock the real buffer if there is no shadow buffer </span>
00189                     ret = lockImpl(offset, length, options);
00190                     mIsLocked = <span class="keyword">true</span>;
00191                 }
00192                 mLockStart = offset;
00193                 mLockSize = length;
00194                 <span class="keywordflow">return</span> ret;
00195             }
00196 
<a name="l00201"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera5">00201</a>             <span class="keywordtype">void</span>* lock(LockOptions options)
00202             {
00203                 <span class="keywordflow">return</span> this-&gt;lock(0, mSizeInBytes, options);
00204             }
<a name="l00217"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera6">00217</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> unlock(<span class="keywordtype">void</span>)
00218             {
00219                 assert(isLocked() &amp;&amp; <span class="stringliteral">"Cannot unlock this buffer, it is not locked!"</span>);
00220 
00221                 <span class="comment">// If we used the shadow buffer this time...</span>
00222                 <span class="keywordflow">if</span> (mUseShadowBuffer &amp;&amp; mpShadowBuffer-&gt;isLocked())
00223                 {
00224                     mpShadowBuffer-&gt;unlock();
00225                     <span class="comment">// Potentially update the 'real' buffer from the shadow buffer</span>
00226                     _updateFromShadow();
00227                 }
00228                 <span class="keywordflow">else</span>
00229                 {
00230                     <span class="comment">// Otherwise, unlock the real one</span>
00231                     unlockImpl();
00232                     mIsLocked = <span class="keyword">false</span>;
00233                 }
00234 
00235             }
00236 
00243             <span class="keyword">virtual</span> <span class="keywordtype">void</span> readData(size_t offset, size_t length, <span class="keywordtype">void</span>* pDest) = 0;
00252             <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeData(size_t offset, size_t length, <span class="keyword">const</span> <span class="keywordtype">void</span>* pSource,
00253                     <span class="keywordtype">bool</span> discardWholeBuffer = <span class="keyword">false</span>) = 0;
00254 
<a name="l00265"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera9">00265</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> copyData(HardwareBuffer&amp; srcBuffer, size_t srcOffset, 
00266                 size_t dstOffset, size_t length, <span class="keywordtype">bool</span> discardWholeBuffer = <span class="keyword">false</span>)
00267             {
00268                 <span class="keyword">const</span> <span class="keywordtype">void</span> *srcData = srcBuffer.<a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera4">lock</a>(
00269                     srcOffset, length, HBL_READ_ONLY);
00270                 this-&gt;writeData(dstOffset, length, srcData, discardWholeBuffer);
00271                 srcBuffer.<a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera6">unlock</a>();
00272             }
00273 
<a name="l00275"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera10">00275</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> _updateFromShadow(<span class="keywordtype">void</span>)
00276             {
00277                 <span class="keywordflow">if</span> (mUseShadowBuffer &amp;&amp; mShadowUpdated &amp;&amp; !mSuppressHardwareUpdate)
00278                 {
00279                     <span class="comment">// Do this manually to avoid locking problems</span>
00280                     <span class="keyword">const</span> <span class="keywordtype">void</span> *srcData = mpShadowBuffer-&gt;lockImpl(
00281                         mLockStart, mLockSize, HBL_READ_ONLY);
00282                     <span class="comment">// Lock with discard if the whole buffer was locked, otherwise normal</span>
00283                     LockOptions lockOpt;
00284                     <span class="keywordflow">if</span> (mLockStart == 0 &amp;&amp; mLockSize == mSizeInBytes)
00285                         lockOpt = HBL_DISCARD;
00286                     <span class="keywordflow">else</span>
00287                         lockOpt = HBL_NORMAL;
00288                     
00289                     <span class="keywordtype">void</span> *destData = this-&gt;lockImpl(
00290                         mLockStart, mLockSize, lockOpt);
00291                     <span class="comment">// Copy shadow to real</span>
00292                     memcpy(destData, srcData, mLockSize);
00293                     this-&gt;unlockImpl();
00294                     mpShadowBuffer-&gt;unlockImpl();
00295                     mShadowUpdated = <span class="keyword">false</span>;
00296                 }
00297             }
00298 
<a name="l00300"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera11">00300</a>             size_t getSizeInBytes(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mSizeInBytes; }
<a name="l00302"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera12">00302</a>             Usage getUsage(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mUsage; }
<a name="l00304"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera13">00304</a>             <span class="keywordtype">bool</span> isSystemMemory(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mSystemMemory; }
<a name="l00306"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera14">00306</a>             <span class="keywordtype">bool</span> hasShadowBuffer(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mUseShadowBuffer; }
<a name="l00308"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera15">00308</a>             <span class="keywordtype">bool</span> isLocked(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ 
00309                 <span class="keywordflow">return</span> mIsLocked || (mUseShadowBuffer &amp;&amp; mpShadowBuffer-&gt;isLocked()); 
00310             }
<a name="l00312"></a><a class="code" href="classOgre_1_1HardwareBuffer.html#Ogre_1_1HardwareVertexBuffera16">00312</a>             <span class="keywordtype">void</span> suppressHardwareUpdate(<span class="keywordtype">bool</span> suppress) {
00313                 mSuppressHardwareUpdate = suppress;
00314                 <span class="keywordflow">if</span> (!suppress)
00315                     _updateFromShadow();
00316             }
00317 
00318 
00319 
00320 
00321             
00322     };
00323 }
00324 <span class="preprocessor">#endif</span>
00325 <span class="preprocessor"></span>
00326 
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Jul 23 10:05:38 2006
</p>
</body>
</html>
