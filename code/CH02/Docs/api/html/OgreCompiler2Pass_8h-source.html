<html>
<head>
<title>OGRE: OgreCompiler2Pass.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="style.css">
</head>

<body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">OgreMain</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">include</a></div>
<h1>OgreCompiler2Pass.h</h1><a href="OgreCompiler2Pass_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">/*</span>
00002 <span class="comment">-----------------------------------------------------------------------------</span>
00003 <span class="comment">This source file is part of OGRE</span>
00004 <span class="comment">    (Object-oriented Graphics Rendering Engine)</span>
00005 <span class="comment">For the latest info, see http://www.stevestreeting.com/ogre/</span>
00006 <span class="comment"></span>
00007 <span class="comment">Copyright (c) 2000-2005 The OGRE Team</span>
00008 <span class="comment">Also see acknowledgements in Readme.html</span>
00009 <span class="comment"></span>
00010 <span class="comment">This program is free software; you can redistribute it and/or modify it under</span>
00011 <span class="comment">the terms of the GNU General Public License as published by the Free Software</span>
00012 <span class="comment">Foundation; either version 2 of the License, or (at your option) any later</span>
00013 <span class="comment">version.</span>
00014 <span class="comment"></span>
00015 <span class="comment">This program is distributed in the hope that it will be useful, but WITHOUT</span>
00016 <span class="comment">ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
00017 <span class="comment">FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</span>
00018 <span class="comment"></span>
00019 <span class="comment">You should have received a copy of the GNU General Public License along with</span>
00020 <span class="comment">this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
00021 <span class="comment">Place - Suite 330, Boston, MA 02111-1307, USA, or go to</span>
00022 <span class="comment">http://www.gnu.org/copyleft/gpl.html.</span>
00023 <span class="comment">-----------------------------------------------------------------------------</span>
00024 <span class="comment">*/</span>
00025 
00026 
00027 <span class="preprocessor">#ifndef __Compiler2Pass_H__</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define __Compiler2Pass_H__</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#include &lt;vector&gt;</span>
00031 <span class="preprocessor">#include "<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>"</span>
00032 
00033 <span class="keyword">namespace </span>Ogre {
00034 
<a name="l00148"></a><a class="code" href="classOgre_1_1Compiler2Pass.html">00148</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a16">_OgreExport</a> Compiler2Pass
00149     {
00150 
00151     <span class="keyword">protected</span>:
00152 
00153         <span class="comment">// BNF operation types</span>
<a name="l00154"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx258">00154</a>         <span class="keyword">enum</span> OperationType {otUNKNOWN, otRULE, otAND, otOR, otOPTIONAL,
00155                             otREPEAT, otDATA, otNOT_TEST, otINSERT_TOKEN, otEND};
00156 
<a name="l00160"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">00160</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>
00161         {
<a name="l00162"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRuleo0">00162</a>             OperationType operation;
<a name="l00163"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRuleo1">00163</a>             size_t tokenID;
00164 
<a name="l00165"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRulea0">00165</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>(<span class="keywordtype">void</span>) : operation(otUNKNOWN), tokenID(0) {}
<a name="l00166"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html#Ogre_1_1Compiler2Pass_1_1TokenRulea1">00166</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenRule.html">TokenRule</a>(<span class="keyword">const</span> OperationType ot, <span class="keyword">const</span> size_t token)
00167                 : operation(ot), tokenID(token) {}
00168         };
00169 
<a name="l00170"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx185">00170</a>         <span class="keyword">typedef</span> std::vector&lt;TokenRule&gt; TokenRuleContainer;
<a name="l00171"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx186">00171</a>         <span class="keyword">typedef</span> TokenRuleContainer::iterator TokenRuleIterator;
00172 
<a name="l00173"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilert3">00173</a>         <span class="keyword">static</span> <span class="keyword">const</span> size_t SystemTokenBase = 1000;
<a name="l00174"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx259">00174</a>         <span class="keyword">enum</span> SystemRuleToken {
00175             _no_token_ = SystemTokenBase,
00176             _character_,
00177             _value_,
00178             _no_space_skip_
00179         };
00180 
<a name="l00181"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx260">00181</a>         <span class="keyword">enum</span> BNF_ID {BNF_UNKOWN = 0,
00182             BNF_SYNTAX, BNF_RULE, BNF_IDENTIFIER, BNF_IDENTIFIER_RIGHT, BNF_IDENTIFIER_CHARACTERS, BNF_ID_BEGIN, BNF_ID_END,
00183             BNF_CONSTANT_BEGIN, BNF_SET_RULE, BNF_EXPRESSION,
00184             BNF_AND_TERM, BNF_OR_TERM, BNF_TERM, BNF_TERM_ID, BNF_CONSTANT, BNF_OR, BNF_TERMINAL_SYMBOL, BNF_TERMINAL_START,
00185             BNF_REPEAT_EXPRESSION, BNF_REPEAT_BEGIN, BNF_REPEAT_END, BNF_SET, BNF_SET_BEGIN, BNF_SET_END,
00186             BNF_NOT_TEST, BNF_NOT_TEST_BEGIN, BNF_CONDITIONAL_TOKEN_INSERT, BNF_OPTIONAL_EXPRESSION,
00187             BNF_NOT_EXPRESSION, BNF_NOT_CHK,
00188             BNF_OPTIONAL_BEGIN, BNF_OPTIONAL_END, BNF_NO_TOKEN_START, BNF_SINGLEQUOTE, BNF_SINGLE_QUOTE_EXC, BNF_SET_END_EXC,
00189             BNF_ANY_CHARACTER, BNF_SPECIAL_CHARACTERS1,
00190             BNF_SPECIAL_CHARACTERS2, BNF_WHITE_SPACE_CHK,
00191 
00192             BNF_LETTER, BNF_LETTER_DIGIT, BNF_DIGIT, BNF_WHITE_SPACE,
00193             BNF_ALPHA_SET, BNF_NUMBER_SET, BNF_SPECIAL_CHARACTER_SET1,
00194             BNF_SPECIAL_CHARACTER_SET2, BNF_SPECIAL_CHARACTER_SET3, BNF_NOT_CHARS
00195         };
00196 
00197 
<a name="l00199"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">00199</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>
00200         {
<a name="l00201"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo0">00201</a>             size_t ID;                  
<a name="l00202"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo1">00202</a>             <span class="keywordtype">bool</span> hasAction;            
<a name="l00203"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo2">00203</a>             <span class="keywordtype">bool</span> isNonTerminal;        
<a name="l00204"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo3">00204</a>             size_t ruleID;              
<a name="l00205"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo4">00205</a>             <span class="keywordtype">bool</span> isCaseSensitive;        
<a name="l00206"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefo5">00206</a>             <a class="code" href="namespaceOgre.html#a471">String</a> lexeme;             
00207 
<a name="l00208"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefa0">00208</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>(<span class="keywordtype">void</span>) : ID(0), hasAction(false), isNonTerminal(false), ruleID(0), isCaseSensitive(false) {}
<a name="l00209"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html#Ogre_1_1Compiler2Pass_1_1LexemeTokenDefa1">00209</a>             <a class="code" href="structOgre_1_1Compiler2Pass_1_1LexemeTokenDef.html">LexemeTokenDef</a>( <span class="keyword">const</span> size_t ID, <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> hasAction = <span class="keyword">false</span>, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span> )
00210                 : ID(ID)
00211                 , hasAction(hasAction)
00212                 , isNonTerminal(false)
00213                 , ruleID(0)
00214                 , isCaseSensitive(caseSensitive)
00215                 , lexeme(lexeme)
00216             {
00217             }
00218 
00219         };
00220 
<a name="l00221"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx187">00221</a>         <span class="keyword">typedef</span> std::vector&lt;LexemeTokenDef&gt; LexemeTokenDefContainer;
<a name="l00222"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx188">00222</a>         <span class="keyword">typedef</span> LexemeTokenDefContainer::iterator LexemeTokenDefIterator;
00223 
<a name="l00224"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx189">00224</a>         <span class="keyword">typedef</span> std::map&lt;std::string, size_t&gt; LexemeTokenMap;
<a name="l00225"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx190">00225</a>         <span class="keyword">typedef</span> LexemeTokenMap::iterator TokenKeyIterator;
00227 
00228 
<a name="l00230"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">00230</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">TokenInst</a>
00231         {
<a name="l00232"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto0">00232</a>         size_t NTTRuleID;           
<a name="l00233"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto1">00233</a>         size_t tokenID;                 
<a name="l00234"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto2">00234</a>         size_t line;                
<a name="l00235"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto3">00235</a>         size_t pos;             
<a name="l00236"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html#Ogre_1_1Compiler2Pass_1_1TokenInsto4">00236</a>         <span class="keywordtype">bool</span> found;                
00237         };
00238 
<a name="l00239"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx191">00239</a>         <span class="keyword">typedef</span> std::vector&lt;TokenInst&gt; TokenInstContainer;
<a name="l00240"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerx192">00240</a>         <span class="keyword">typedef</span> TokenInstContainer::iterator TokenInstIterator;
00241 
00242         <span class="comment">// token que, definitions, rules</span>
<a name="l00243"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">00243</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>
00244         {
<a name="l00245"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo0">00245</a>             TokenInstContainer       tokenQue;
<a name="l00246"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo1">00246</a>             LexemeTokenDefContainer  lexemeTokenDefinitions;
<a name="l00247"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo2">00247</a>             TokenRuleContainer       rootRulePath;
<a name="l00248"></a><a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html#Ogre_1_1Compiler2Pass_1_1TokenStateo3">00248</a>             LexemeTokenMap           lexemeTokenMap;
00249         };
00250 
<a name="l00251"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp1">00251</a>         <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>* mClientTokenState;
00252 
<a name="l00254"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp2">00254</a>         <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a>* mActiveTokenState;
<a name="l00256"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp3">00256</a>         <span class="keyword">mutable</span> size_t mPass2TokenQuePosition;
<a name="l00260"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp4">00260</a>         size_t mPreviousActionQuePosition;
<a name="l00263"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp5">00263</a>         size_t mNextActionQuePosition;
00264 
<a name="l00266"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp6">00266</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>* mSource;
<a name="l00268"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp7">00268</a>         <a class="code" href="namespaceOgre.html#a471">String</a> mSourceName;
<a name="l00269"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp8">00269</a>         size_t mEndOfSource;
00270 
<a name="l00271"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp9">00271</a>         size_t mCurrentLine; 
<a name="l00272"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp10">00272</a>         size_t mCharPos;     
<a name="l00273"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp11">00273</a>         size_t mErrorCharPos; 
00274 
<a name="l00277"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp12">00277</a>         std::map&lt;size_t, float&gt; mConstants;
<a name="l00280"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp13">00280</a>         std::map&lt;size_t, String&gt; mLabels;
<a name="l00283"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp14">00283</a>         <span class="keywordtype">bool</span> mLabelIsActive;
<a name="l00286"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp15">00286</a>         size_t mActiveLabelKey;
<a name="l00289"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp16">00289</a>         <span class="keywordtype">bool</span> mNoSpaceSkip;
<a name="l00292"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp17">00292</a>         <span class="keywordtype">bool</span> mNoTerminalToken;
<a name="l00295"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp18">00295</a>         size_t mInsertTokenID;
00296 
<a name="l00298"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerp19">00298</a>         <a class="code" href="namespaceOgre.html#a468">uint</a> mActiveContexts;
00299 
00308         <span class="keywordtype">bool</span> doPass1();
00309 
00319         <span class="keywordtype">bool</span> doPass2();
00320 
00327         <span class="keyword">virtual</span> <span class="keywordtype">void</span> executeTokenAction(<span class="keyword">const</span> size_t tokenID) = 0;
00330         <span class="keyword">virtual</span> <span class="keywordtype">void</span> setupTokenDefinitions(<span class="keywordtype">void</span>) = 0;
<a name="l00339"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb92">00339</a>         <span class="keyword">const</span> <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenInst.html">TokenInst</a>&amp; getNextToken(<span class="keyword">const</span> size_t expectedTokenID = 0)<span class="keyword"> const</span>
00340 <span class="keyword">        </span>{
00341             skipToken();
00342             <span class="keywordflow">return</span> getCurrentToken(expectedTokenID);
00343         }
00352         <span class="keyword">const</span> TokenInst&amp; getCurrentToken(<span class="keyword">const</span> size_t expectedTokenID = 0) <span class="keyword">const</span>;
00359         <span class="keywordtype">bool</span> testNextTokenID(<span class="keyword">const</span> size_t expectedTokenID) <span class="keyword">const</span>;
00360 
<a name="l00364"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb95">00364</a>         <span class="keywordtype">bool</span> testCurrentTokenID(<span class="keyword">const</span> size_t expectedTokenID)<span class="keyword"> const</span>
00365 <span class="keyword">        </span>{
00366             <span class="keywordflow">return</span> mActiveTokenState-&gt;tokenQue[mPass2TokenQuePosition].tokenID == expectedTokenID;
00367         }
00370         <span class="keywordtype">void</span> skipToken(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00373         <span class="keywordtype">void</span> replaceToken(<span class="keywordtype">void</span>);
<a name="l00379"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb98">00379</a>         <span class="keywordtype">float</span> getNextTokenValue(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00380 <span class="keyword">        </span>{
00381             skipToken();
00382             <span class="keywordflow">return</span> getCurrentTokenValue();
00383         }
00390         <span class="keywordtype">float</span> getCurrentTokenValue(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00398"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb100">00398</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getNextTokenLabel(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00399 <span class="keyword">        </span>{
00400             skipToken();
00401             <span class="keywordflow">return</span> getCurrentTokenLabel();
00402         }
00407         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getCurrentTokenLabel(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l00410"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb102">00410</a>         size_t getNextTokenID(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> getNextToken().tokenID; }
<a name="l00413"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb103">00413</a>         size_t getCurrentTokenID(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> getCurrentToken().tokenID; }
<a name="l00417"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb104">00417</a>         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getNextTokenLexeme(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
00418 <span class="keyword">        </span>{
00419             skipToken();
00420             <span class="keywordflow">return</span> getCurrentTokenLexeme();
00421         }
00425         <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getCurrentTokenLexeme(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00428         size_t getPass2TokenQueCount(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00433         size_t getRemainingTokensForAction(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
00444         <span class="keywordtype">void</span> setPass2TokenQuePosition(size_t pos, <span class="keyword">const</span> <span class="keywordtype">bool</span> activateAction = <span class="keyword">false</span>);
<a name="l00447"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb109">00447</a>         size_t getPass2TokenQuePosition(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mPass2TokenQuePosition; }
00457         <span class="keywordtype">bool</span> setNextActionQuePosition(size_t pos, <span class="keyword">const</span> <span class="keywordtype">bool</span> search = <span class="keyword">false</span>);
00468         <span class="keywordtype">void</span> addLexemeToken(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; lexeme, <span class="keyword">const</span> size_t token, <span class="keyword">const</span> <span class="keywordtype">bool</span> hasAction = <span class="keyword">false</span>, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive = <span class="keyword">false</span>);
00469 
00480         <span class="keywordtype">void</span> setClientBNFGrammer(<span class="keywordtype">void</span>);
00481 
00482 
00483 
00485         <span class="keywordtype">void</span> findEOL();
00486 
00494         <span class="keywordtype">bool</span> isFloatValue(<span class="keywordtype">float</span>&amp; fvalue, size_t&amp; charsize) <span class="keyword">const</span>;
00495 
00504         <span class="keywordtype">bool</span> isCharacterLabel(<span class="keyword">const</span> size_t rulepathIDX);
00512         <span class="keywordtype">bool</span> isLexemeMatch(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> caseSensitive) <span class="keyword">const</span>;
00514         <span class="keywordtype">bool</span> positionToNextLexeme();
00535         <span class="keywordtype">bool</span> processRulePath( size_t rulepathIDX);
00536 
00537 
<a name="l00540"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1MaterialScriptCompilerb119">00540</a>         <span class="keywordtype">void</span> setActiveContexts(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a468">uint</a> contexts){ mActiveContexts = contexts; }
00541 
00543         <span class="keywordtype">void</span> skipComments();
00544 
00546         <span class="keywordtype">void</span> skipEOL();
00547 
00549         <span class="keywordtype">void</span> skipWhiteSpace();
00550 
00551 
00560         <span class="keywordtype">bool</span> ValidateToken(<span class="keyword">const</span> size_t rulepathIDX, <span class="keyword">const</span> size_t activeRuleID);
00561 
00566         <span class="keywordtype">void</span> verifyTokenRuleLinks(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; grammerName);
00570         <span class="keywordtype">void</span> checkTokenActionTrigger(<span class="keywordtype">void</span>);
00577         <a class="code" href="namespaceOgre.html#a471">String</a> getBNFGrammerTextFromRulePath(size_t ruleID, <span class="keyword">const</span> size_t level = 0);
00578 
00579 
00580     <span class="keyword">private</span>:
00581         <span class="comment">// used for interpreting BNF script</span>
00582         <span class="comment">// keep it as static so that only one structure is created</span>
00583         <span class="comment">// no matter how many times this class is instantiated.</span>
<a name="l00584"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passv0">00584</a>         <span class="keyword">static</span> <a class="code" href="structOgre_1_1Compiler2Pass_1_1TokenState.html">TokenState</a> mBNFTokenState;
00585         <span class="comment">// maintain a map of BNF grammer</span>
<a name="l00586"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passy0">00586</a>         <span class="keyword">typedef</span> std::map&lt;String, TokenState&gt; TokenStateContainer;
<a name="l00587"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passv1">00587</a>         <span class="keyword">static</span> TokenStateContainer mClientTokenStates;
00589         <span class="keywordtype">void</span> activatePreviousTokenAction(<span class="keywordtype">void</span>);
00591         <span class="keywordtype">void</span> initBNFCompiler(<span class="keywordtype">void</span>);
00593         <span class="keywordtype">void</span> buildClientBNFRulePaths(<span class="keywordtype">void</span>);
00595         <span class="keywordtype">void</span> modifyLastRule(<span class="keyword">const</span> OperationType pendingRuleOp, <span class="keyword">const</span> size_t tokenID);
00600         size_t getClientLexemeTokenID(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; lexeme, <span class="keyword">const</span> <span class="keywordtype">bool</span> isCaseSensitive = <span class="keyword">false</span>);
00602         <span class="keywordtype">void</span> extractNonTerminal(<span class="keyword">const</span> OperationType pendingRuleOp);
00604         <span class="keywordtype">void</span> extractTerminal(<span class="keyword">const</span> OperationType pendingRuleOp, <span class="keyword">const</span> <span class="keywordtype">bool</span> notoken = <span class="keyword">false</span>);
00606         <span class="keywordtype">void</span> extractSet(<span class="keyword">const</span> OperationType pendingRuleOp);
00608         <span class="keywordtype">void</span> extractNumericConstant(<span class="keyword">const</span> OperationType pendingRuleOp);
00610         <span class="keywordtype">void</span> setConditionalTokenInsert(<span class="keywordtype">void</span>);
00612         <a class="code" href="namespaceOgre.html#a471">String</a> getLexemeText(size_t&amp; ruleID, <span class="keyword">const</span> size_t level = 0);
00613 
00614     <span class="keyword">public</span>:
00615 
00617         Compiler2Pass();
<a name="l00618"></a><a class="code" href="classOgre_1_1Compiler2Pass.html#Ogre_1_1Compiler2Passa1">00618</a>         <span class="keyword">virtual</span> ~Compiler2Pass() {}
00619 
00631         <span class="keywordtype">bool</span> compile(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; source, <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; sourceName);
00634         <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getClientBNFGrammer(<span class="keywordtype">void</span>) = 0;
00635 
00638         <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#a471">String</a>&amp; getClientGrammerName(<span class="keywordtype">void</span>) <span class="keyword">const </span>= 0;
00639 
00640     };
00641 
00642 }
00643 
00644 <span class="preprocessor">#endif</span>
00645 <span class="preprocessor"></span>
</pre></div><hr>
<p>
Copyright &copy; 2000-2005 by The OGRE Team<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/"><img alt="Creative Commons License" border="0" src="http://creativecommons.org/images/public/somerights20.png"/></a><br/>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/2.5/">Creative Commons Attribution-ShareAlike 2.5 License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Jul 23 10:05:37 2006
</p>
</body>
</html>
